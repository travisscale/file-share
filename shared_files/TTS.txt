
# # =-============================================================================
# # ç¬¬0éƒ¨åˆ†ï¼šå¯¼å…¥åº“ä¸å…¨å±€åˆå§‹åŒ–
# # ==============================================================================
# import edge_tts
# import pygame
# import asyncio
# import os
# import pandas as pd
# import sys
# import random
# import time
# import threading
# from thefuzz import process
# import hashlib
# import shutil
# import subprocess
# import requests
# import openpyxl
# import json
# import difflib
# import string

# try:
#     from aiohttp.client_exceptions import WSServerHandshakeError
# except ImportError:
#     class WSServerHandshakeError(Exception): pass

# class UnauthorizedError(Exception):
#     pass

# # ç”¨äºåœ¨ç»ˆç«¯æ‰“å°å½©è‰²æ–‡å­—
# class bcolors:
#     RED = '\033[91m'
#     GREEN = '\033[92m'
#     YELLOW = '\033[93m'
#     BLUE = '\033[94m'
#     CYAN = '\033[96m'
#     ENDC = '\033[0m'

# class UI:
#     WIDTH = 60
#     @staticmethod
#     def separator():
#         print(bcolors.CYAN + "-" * UI.WIDTH + bcolors.ENDC)
#     @staticmethod
#     def header(text):
#         width = 40
#         print(bcolors.BLUE + "#" * width)
#         print(f"###{(text.center(width - 6))}###")
#         print("#" * width + bcolors.ENDC)
#         UI.separator()
#     @staticmethod
#     def prompt(text):
#         response = input(f"{bcolors.YELLOW}â“ {text}{bcolors.ENDC}")
#         UI.separator()
#         return response
#     @staticmethod
#     def info(text):
#         print(f"{bcolors.YELLOW}â„¹ï¸  {text}{bcolors.ENDC}")
#     @staticmethod
#     def success(text):
#         print(f"{bcolors.GREEN}âœ… {text}{bcolors.ENDC}")
#     @staticmethod
#     def error(text):
#         print(f"{bcolors.RED}âŒ {text}{bcolors.ENDC}")

# pygame.mixer.init()
# UI.success("Pygame Mixer å·²æˆåŠŸåˆå§‹åŒ–ã€‚")
# UI.separator()


# # ==============================================================================
# # ç¬¬1éƒ¨åˆ†ï¼šè¯­éŸ³æœ—è¯»åº”ç”¨ (ä»£ç 1) - æ ¸å¿ƒå‡½æ•°ä¸é…ç½®
# # ==============================================================================
# CACHE_DIR = "audio_cache"
# STATE_FILE = "run_state.txt"
# LEFTOVER_FILE = "leftover_sentences.txt"
# SPELLING_ERROR_FILE = "spelling_errors.txt"
# SPEECH_EXCEL_PATH = r'C:\Users\Administrator\Desktop\è‹±å›½è€é¼ \å·¥ä½œç°¿1.xlsm'
# os.makedirs(CACHE_DIR, exist_ok=True)

# VOICE_SCORE_FILE = "voice_scores.json"
# PRIMARY_RETRY_LIMIT = 50
# FALLBACK_RETRY_LIMIT = 10
# FALLBACK_COUNTRY = "United Kingdom"
# # (è¯­éŸ³åº“æ•°æ®å’Œå›½å®¶ä»£ç æ˜ å°„çœç•¥ï¼Œä¸å‰ç‰ˆç›¸åŒ)
# voices_by_country = { "Afghanistan": ["ps-AF-GulNawazNeural", "ps-AF-LatifaNeural", "fa-AF-DilaraNeural", "fa-AF-FaridNeural"], "Albania": ["sq-AL-AnilaNeural", "sq-AL-IlirNeural"], "Algeria": ["ar-DZ-AminaNeural", "ar-DZ-IsmaelNeural"], "Argentina": ["es-AR-ElenaNeural", "es-AR-TomasNeural"], "Armenia": ["hy-AM-AnahitNeural", "hy-AM-HaykNeural"], "Australia": ["en-AU-NatashaNeural", "en-AU-WilliamNeural"], "Austria": ["de-AT-IngridNeural", "de-AT-JonasNeural"], "Azerbaijan": ["az-AZ-BabekNeural", "az-AZ-BanuNeural"], "Bahrain": ["ar-BH-AliNeural", "ar-BH-LailaNeural"], "Bangladesh": ["bn-BD-NabanitaNeural", "bn-BD-PradeepNeural"], "Basque": ["eu-ES-AinhoaNeural", "eu-ES-AnderNeural"], "Belarus": ["be-BY-AnastasiyaNeural", "be-BY-PavelNeural"], "Belgium": ["nl-BE-ArnaudNeural", "nl-BE-DenaNeural", "fr-BE-CharlineNeural", "fr-BE-GerardNeural"], "Bolivia": ["es-BO-MarceloNeural", "es-BO-SofiaNeural"], "Bosnia and Herzegovina": ["bs-BA-GoranNeural", "bs-BA-VesnaNeural"], "Brazil": ["pt-BR-AntonioNeural", "pt-BR-FranciscaNeural", "pt-BR-ThalitaNeural", "pt-BR-DonatoNeural", "pt-BR-BrendaNeural", "pt-BR-GiovannaNeural", "pt-BR-HumbertoNeural", "pt-BR-LeilaNeural", "pt-BR-LeticiaNeural", "pt-BR-ManuelaNeural", "pt-BR-NicolauNeural", "pt-BR-ValerioNeural", "pt-BR-YaraNeural"], "Bulgaria": ["bg-BG-BorislavNeural", "bg-BG-KalinaNeural"], "Burma": ["my-MM-NilarNeural", "my-MM-ThihaNeural"], "Cambodia": ["km-KH-PisethNeural", "km-KH-SreymomNeural"], "Canada": ["en-CA-ClaraNeural", "en-CA-LiamNeural", "fr-CA-AntoineNeural", "fr-CA-JeanNeural", "fr-CA-SylvieNeural", "fr-CA-HenriNeural"], "Catalan": ["ca-ES-EnricNeural", "ca-ES-JoanaNeural", "ca-ES-AlbaNeural"], "Chile": ["es-CL-LorenzoNeural", "es-CL-SofiaNeural"], "China (Liaoning)": ["zh-CN-liaoning-XiaobeiNeural"], "China (Mainland)": ["zh-CN-XiaoxiaoNeural", "zh-CN-XiaoyouNeural", "zh-CN-YunxiNeural", "zh-CN-YunyangNeural", "zh-CN-YunyeNeural", "zh-CN-YunjianNeural", "zh-CN-XiaoyiNeural", "zh-CN-YunzeNeural", "zh-CN-XiaochenNeural", "zh-CN-XiaohanNeural", "zh-CN-XiaomengNeural", "zh-CN-XiaomoNeural", "zh-CN-XiaoqiuNeural", "zh-CN-XiaoruiNeural", "zh-CN-XiaoshuangNeural", "zh-CN-XiaoxuanNeural", "zh-CN-XiaoyanNeural", "zh-CN-XiaozhenNeural"], "China (Shaanxi)": ["zh-CN-shaanxi-XiaoniNeural"], "Colombia": ["es-CO-GonzaloNeural", "es-CO-SalomeNeural"], "Costa Rica": ["es-CR-JuanNeural", "es-CR-MariaNeural"], "Croatia": ["hr-HR-GabrijelaNeural", "hr-HR-SreckoNeural"], "Cuba": ["es-CU-ManuelNeural", "es-CU-YarinaNeural"], "Cyprus": ["el-CY-AndreasNeural", "el-CY-NafsikaNeural"], "Czech Republic": ["cs-CZ-AntoninNeural", "cs-CZ-VlastaNeural"], "Denmark": ["da-DK-ChristelNeural", "da-DK-JeppeNeural"], "Dominican Republic": ["es-DO-EmilioNeural", "es-DO-RamonaNeural"], "Ecuador": ["es-EC-AndreaNeural", "es-EC-LuisNeural"], "Egypt": ["ar-EG-SalmaNeural", "ar-EG-ShakirNeural"], "El Salvador": ["es-SV-LorenaNeural", "es-SV-RodrigoNeural"], "Equatorial Guinea": ["es-GQ-JavierNeural", "es-GQ-TeresaNeural"], "Estonia": ["et-EE-AnuNeural", "et-EE-KertNeural"], "Ethiopia": ["am-ET-AmehaNeural", "am-ET-MekdesNeural"], "Finland": ["fi-FI-HarriNeural", "fi-FI-NooraNeural", "fi-FI-SelmaNeural"], "France": ["fr-FR-DeniseNeural", "fr-FR-EloiseNeural", "fr-FR-HenriNeural", "fr-FR-AlainNeural", "fr-FR-BrigitteNeural", "fr-FR-CelesteNeural", "fr-FR-ClaudeNeural", "fr-FR-CoralieNeural", "fr-FR-JacquelineNeural", "fr-FR-JeromeNeural", "fr-FR-JosephineNeural", "fr-FR-MauriceNeural", "fr-FR-YvesNeural", "fr-FR-YvetteNeural"], "Galician": ["gl-ES-RoiNeural", "gl-ES-SabelaNeural"], "Georgia": ["ka-GE-EkaNeural", "ka-GE-GiorgiNeural"], "Germany": ["de-DE-AmalaNeural", "de-DE-ConradNeural", "de-DE-KatjaNeural", "de-DE-KillianNeural", "de-DE-ElkeNeural", "de-DE-GiselaNeural", "de-DE-KasperNeural"], "Greece": ["el-GR-AthinaNeural", "el-GR-NestorasNeural"], "Guatemala": ["es-GT-AndresNeural", "es-GT-MartaNeural"], "Honduras": ["es-HN-CarlosNeural", "es-HN-KarlaNeural"], "Hong Kong Sar": ["en-HK-SamNeural", "en-HK-YanNeural", "zh-HK-HiuGaaiNeural", "zh-HK-HiuMaanNeural", "zh-HK-WanLungNeural"], "Hungary": ["hu-HU-NoemiNeural", "hu-HU-TamasNeural"], "Iceland": ["is-IS-GudrunNeural", "is-IS-GunnarNeural"], "India": ["en-IN-NeerjaNeural", "en-IN-PrabhatNeural", "bn-IN-BashkarNeural", "bn-IN-TanishaNeural", "gu-IN-DhwaniNeural", "gu-IN-NiranjanNeural", "hi-IN-MadhurNeural", "hi-IN-SwaraNeural", "kn-IN-GaganNeural", "kn-IN-SapnaNeural", "ml-IN-MidhunNeural", "ml-IN-SobhanaNeural", "mr-IN-AarohiNeural", "mr-IN-ManoharNeural", "ta-IN-PallaviNeural", "ta-IN-ValluvarNeural", "te-IN-MohanNeural", "te-IN-ShrutiNeural", "ur-IN-GulNeural", "ur-IN-SalmanNeural"], "Indonesia": ["id-ID-ArdiNeural", "id-ID-GadisNeural", "jv-ID-DimasNeural", "jv-ID-SitiNeural", "su-ID-JajangNeural", "su-ID-TutiNeural"], "Iran": ["fa-IR-DilaraNeural", "fa-IR-FaridNeural"], "Iraq": ["ar-IQ-BasselNeural", "ar-IQ-RanaNeural"], "Ireland": ["en-IE-ConnorNeural", "en-IE-EmilyNeural", "ga-IE-ColmNeural", "ga-IE-OrlaNeural"], "Israel": ["he-IL-AvriNeural", "he-IL-HilaNeural"], "Italy": ["it-IT-DiegoNeural", "it-IT-ElsaNeural", "it-IT-IsabellaNeural", "it-IT-BenignoNeural", "it-IT-CalimeroNeural", "it-IT-CataldoNeural", "it-IT-FabiolaNeural", "it-IT-FiammaNeural", "it-IT-GianniNeural", "it-IT-ImeldaNeural", "it-IT-IrmaNeural", "it-IT-LisandroNeural", "it-IT-PalmiraNeural", "it-IT-PierinaNeural", "it-IT-RinaldoNeural"], "Japan": ["ja-JP-KeitaNeural", "ja-JP-NanamiNeural", "ja-JP-AoiNeural", "ja-JP-DaichiNeural", "ja-JP-MayuNeural", "ja-JP-NaokiNeural", "ja-JP-ShioriNeural"], "Jordan": ["ar-JO-SanaNeural", "ar-JO-TaimNeural"], "Kazakhstan": ["kk-KZ-AigulNeural", "kk-KZ-DauletNeural"], "Kenya": ["en-KE-AsiliaNeural", "en-KE-ChilembaNeural", "sw-KE-RafikiNeural", "sw-KE-ZuriNeural"], "Kuwait": ["ar-KW-FahedNeural", "ar-KW-NouraNeural"], "Kyrgyzstan": ["ky-KG-AibekNeural", "ky-KG-MederimNeural"], "Laos": ["lo-LA-ChanthavongNeural", "lo-LA-KeomanyNeural"], "Latvia": ["lv-LV-EveritaNeural", "lv-LV-NilsNeural"], "Lebanon": ["ar-LB-LaylaNeural", "ar-LB-RamiNeural"], "Libya": ["ar-LY-ImanNeural", "ar-LY-OmarNeural"], "Lithuania": ["lt-LT-LeonasNeural", "lt-LT-OnaNeural"], "Macedonia": ["mk-MK-AleksandarNeural", "mk-MK-MarijaNeural"], "Malaysia": ["ms-MY-OsmanNeural", "ms-MY-YasminNeural", "ta-MY-KaniNeural", "ta-MY-SuryaNeural"], "Mali": ["bm-ML-AdamaNeural", "bm-ML-FantaNeural"], "Malta": ["mt-MT-GraceNeural", "mt-MT-JosephNeural"], "Mexico": ["es-MX-DaliaNeural", "es-MX-JorgeNeural", "es-MX-BeatrizNeural", "es-MX-CandelaNeural", "es-MX-CarlotaNeural", "es-MX-CecilioNeural", "es-MX-GerardoNeural", "es-MX-LarissaNeural", "es-MX-LibertoNeural", "es-MX-LucianoNeural", "es-MX-MarinaNeural", "es-MX-NuriaNeural", "es-MX-PelayoNeural", "es-MX-RenataNeural", "es-MX-YagoNeural"], "Moldova": ["ro-MD-AnastasiaNeural", "ro-MD-VitalieNeural"], "Mongolia": ["mn-MN-BataaNeural", "mn-MN-YesuiNeural"], "Montenegro": ["sr-ME-JovanNeural", "sr-ME-PetarNeural"], "Morocco": ["ar-MA-JamalNeural", "ar-MA-MounaNeural"], "Nepal": ["ne-NP-SagarNeural", "ne-NP-AmritaNeural"], "Netherlands": ["nl-NL-ColetteNeural", "nl-NL-FennaNeural", "nl-NL-MaartenNeural"], "New Zealand": ["en-NZ-MitchellNeural", "en-NZ-MollyNeural"], "Nicaragua": ["es-NI-FedericoNeural", "es-NI-YolandaNeural"], "Nigeria": ["en-NG-AbeoNeural", "en-NG-EzinneNeural"], "Norway": ["nb-NO-FinnNeural", "nb-NO-PernilleNeural", "nb-NO-IselinNeural"], "Oman": ["ar-OM-AbdullahNeural", "ar-OM-AyshaNeural"], "Pakistan": ["ur-PK-AsadNeural", "ur-PK-UzmaNeural"], "Panama": ["es-PA-MargaritaNeural", "es-PA-RobertoNeural"], "Paraguay": ["es-PY-MarioNeural", "es-PY-TaniaNeural"], "Peru": ["es-PE-AlexNeural", "es-PE-CamilaNeural"], "Philippines": ["en-PH-JamesNeural", "en-PH-RosaNeural", "fil-PH-AngeloNeural", "fil-PH-BlessicaNeural"], "Poland": ["pl-PL-MarekNeural", "pl-PL-ZofiaNeural", "pl-PL-AgnieszkaNeural"], "Portugal": ["pt-PT-DuarteNeural", "pt-PT-FernandaNeural", "pt-PT-RaquelNeural"], "Puerto Rico": ["es-PR-KarinaNeural", "es-PR-VictorNeural"], "Qatar": ["ar-QA-AmalNeural", "ar-QA-MoazNeural"], "Romania": ["ro-RO-AlinaNeural", "ro-RO-EmilNeural"], "Russia": ["ru-RU-DmitryNeural", "ru-RU-SvetlanaNeural", "ru-RU-DariyaNeural"], "Saudi Arabia": ["ar-SA-HamedNeural", "ar-SA-ZariyahNeural"], "Senegal": ["wo-SN-AlphaNeural", "wo-SN-KhadijaNeural"], "Serbia": ["sr-RS-NicholasNeural", "sr-RS-SophieNeural"], "Singapore": ["en-SG-LunaNeural", "en-SG-WayneNeural", "ta-SG-AnbuNeural", "ta-SG-VenbaNeural"], "Slovakia": ["sk-SK-LukasNeural", "sk-SK-ViktoriaNeural"], "Slovenia": ["sl-SI-PetraNeural", "sl-SI-RokNeural"], "Somalia": ["so-SO-MuuseNeural", "so-SO-UbaxNeural"], "South Africa": ["en-ZA-LeahNeural", "en-ZA-LukeNeural", "af-ZA-AdriNeural", "af-ZA-WillemNeural", "zu-ZA-ThandoNeural", "zu-ZA-ThembaNeural"], "South Korea": ["ko-KR-InJoonNeural", "ko-KR-SunHiNeural", "ko-KR-BongJinNeural", "ko-KR-GookMinNeural", "ko-KR-HyunsuNeural", "ko-KR-JiMinNeural", "ko-KR-SeoHyeonNeural", "ko-KR-SoonBokNeural", "ko-KR-YuJinNeural"], "Spain": ["es-ES-AlvaroNeural", "es-ES-ElviraNeural", "es-ES-AbrilNeural", "es-ES-ArnauNeural", "es-ES-DarioNeural", "es-ES-EliasNeural", "es-ES-EstrellaNeural", "es-ES-IreneNeural", "es-ES-LaiaNeural", "es-ES-LiaNeural", "es-ES-NilNeural", "es-ES-SaulNeural", "es-ES-TeoNeural", "es-ES-TrianaNeural", "es-ES-VeraNeural"], "Sri Lanka": ["si-LK-DinuraNeural", "si-LK-ThiliniNeural", "ta-LK-KumarNeural", "ta-LK-SaranyaNeural"], "Sweden": ["sv-SE-MattiasNeural", "sv-SE-SofieNeural", "sv-SE-HilleviNeural"], "Switzerland": ["de-CH-JanNeural", "de-CH-LeniNeural", "fr-CH-ArianeNeural", "fr-CH-FabriceNeural", "it-CH-GiuseppeNeural", "it-CH-IsidoraNeural"], "Syria": ["ar-SY-AmanyNeural", "ar-SY-LaithNeural"], "Taiwan": ["zh-TW-HsiaoChenNeural", "zh-TW-HsiaoYuNeural", "zh-TW-YunJheNeural"], "Tanzania": ["en-TZ-ElimuNeural", "en-TZ-ImaniNeural", "sw-TZ-DaudiNeural", "sw-TZ-RehemaNeural"], "Thailand": ["th-TH-NiwatNeural", "th-TH-PremwadeeNeural"], "Tunisia": ["ar-TN-HediNeural", "ar-TN-ReemNeural"], "Turkey": ["tr-TR-AhmetNeural", "tr-TR-EmelNeural"], "Turkmenistan": ["tk-TM-MerdanNeural", "tk-TM-TovusNeural"], "Ukraine": ["uk-UA-OstapNeural", "uk-UA-PolinaNeural"], "United Arab Emirates": ["ar-AE-FatimaNeural", "ar-AE-HamdanNeural"], "United Kingdom": ["en-GB-LibbyNeural", "en-GB-MaisieNeural", "en-GB-RyanNeural", "en-GB-SoniaNeural", "en-GB-ThomasNeural", "en-GB-AbbiNeural", "en-GB-AlfieNeural", "en-GB-BellaNeural", "en-GB-ElliotNeural", "en-GB-EthanNeural", "en-GB-HollieNeural", "en-GB-NoahNeural", "en-GB-OliverNeural", "en-GB-OliviaNeural"], "United States": ["en-US-JennyNeural", "en-US-GuyNeural", "en-US-AriaNeural",  "en-US-TonyNeural", "en-US-AnaNeural", "en-US-AndrewNeural", "en-US-BrianNeural", "en-US-ChristopherNeural", "en-US-EmmaNeural", "en-US-EricNeural",  "en-US-MichelleNeural","en-US-RogerNeural", "en-US-SteffanNeural", "es-US-AlonsoNeural", "es-US-PalomaNeural"], "Uruguay": ["es-UY-FacundoNeural", "es-UY-ValentinaNeural"], "Uzbekistan": ["uz-UZ-MadinaNeural", "uz-UZ-SardorNeural"], "Venezuela": ["es-VE-PaolaNeural", "es-VE-SebastianNeural"], "Vietnam": ["vi-VN-HoaiMyNeural", "vi-VN-NamMinhNeural"], "Wales": ["cy-GB-AledNeural", "cy-GB-NiaNeural"], "Yemen": ["ar-YE-MaryamNeural", "ar-YE-SalehNeural"] }
# country_code_map = { "AF": "Afghanistan", "AL": "Albania", "DZ": "Algeria", "AR": "Argentina", "AM": "Armenia", "AU": "Australia", "AT": "Austria", "AZ": "Azerbaijan", "BH": "Bahrain", "BD": "Bangladesh", "BY": "Belarus", "BE": "Belgium", "BO": "Bolivia", "BA": "Bosnia and Herzegovina", "BR": "Brazil", "BG": "Bulgaria", "MM": "Burma", "KH": "Cambodia", "CA": "Canada", "CL": "Chile", "CN": "China (Mainland)", "CN-LN": "China (Liaoning)", "CN-SN": "China (Shaanxi)", "CO": "Colombia", "CR": "Costa Rica", "HR": "Croatia", "CU": "Cuba", "CY": "Cyprus", "CZ": "Czech Republic", "DK": "Denmark", "DO": "Dominican Republic", "EC": "Ecuador", "EG": "Egypt", "SV": "El Salvador", "GQ": "Equatorial Guinea", "EE": "Estonia", "ET": "Ethiopia", "FI": "Finland", "FR": "France", "GE": "Georgia", "DE": "Germany", "GR": "Greece", "GT": "Guatemala", "HN": "Honduras", "HK": "Hong Kong Sar", "HU": "Hungary", "IS": "Iceland", "IN": "India", "ID": "Indonesia", "IR": "Iran", "IQ": "Iraq", "IE": "Ireland", "IL": "Israel", "IT": "Italy", "JP": "Japan", "JO": "Jordan", "KZ": "Kazakhstan", "KE": "Kenya", "KW": "Kuwait", "KG": "Kyrgyzstan", "LA": "Laos", "LV": "Latvia", "LB": "Lebanon", "LY": "Libya", "LT": "Lithuania", "MK": "Macedonia", "MY": "Malaysia", "ML": "Mali", "MT": "Malta", "MX": "Mexico", "MD": "Moldova", "MN": "Mongolia", "ME": "Montenegro", "MA": "Morocco", "NP": "Nepal", "NL": "Netherlands", "NZ": "New Zealand", "NI": "Nicaragua", "NG": "Nigeria", "NO": "Norway", "OM": "Oman", "PK": "Pakistan", "PA": "Panama", "PY": "Paraguay", "PE": "Peru", "PH": "Philippines", "PL": "Poland", "PT": "Portugal", "PR": "Puerto Rico", "QA": "Qatar", "RO": "Romania", "RU": "Russia", "SA": "Saudi Arabia", "SN": "Senegal", "RS": "Serbia", "SG": "Singapore", "SK": "Slovakia", "SI": "Slovenia", "SO": "Somalia", "ZA": "South Africa", "KR": "South Korea", "ES": "Spain", "LK": "Sri Lanka", "SE": "Sweden", "CH": "Switzerland", "SY": "Syria", "TW": "Taiwan", "TZ": "Tanzania", "TH": "Thailand", "TN": "Tunisia", "TR": "Turkey", "TM": "Turkmenistan", "UA": "Ukraine", "AE": "United Arab Emirates", "GB": "United Kingdom", "UK": "United Kingdom", "US": "United States", "UY": "Uruguay", "UZ": "Uzbekistan", "VE": "Venezuela", "VN": "Vietnam", "YE": "Yemen" }

# def load_voice_scores():
#     if not os.path.exists(VOICE_SCORE_FILE): return {}
#     try:
#         with open(VOICE_SCORE_FILE, 'r', encoding='utf-8') as f: return json.load(f)
#     except (json.JSONDecodeError, IOError): return {}
# def save_voice_scores(scores):
#     try:
#         with open(VOICE_SCORE_FILE, 'w', encoding='utf-8') as f: json.dump(scores, f, indent=4)
#     except IOError: UI.error(f"æ— æ³•å†™å…¥å£°éŸ³è¯„åˆ†æ–‡ä»¶ {VOICE_SCORE_FILE}")
# def update_voice_score(voice, change):
#     scores = load_voice_scores(); scores[voice] = scores.get(voice, 0) + change; save_voice_scores(scores)
# def get_prioritized_voices(country_voices, scores, tried_voices):
#     available_voices = [v for v in country_voices if v not in tried_voices]
#     return sorted(available_voices, key=lambda v: scores.get(v, 0), reverse=True)
# def handle_auth_error_and_exit():
#     UI.error("æ‰€æœ‰é‡è¯•å°è¯•å‡å¤±è´¥ï¼ŒåŒ…æ‹¬é™çº§åˆ°è‹±å›½å£éŸ³ã€‚"); UI.info("è¿™å¾ˆå¯èƒ½æ˜¯å› ä¸ºåº“ç‰ˆæœ¬è¿‡æ—§ã€‚æ­£åœ¨å°è¯•è‡ªåŠ¨æ›´æ–°...");
#     try:
#         command = [sys.executable, "-m", "pip", "install", "--upgrade", "edge-tts"]; subprocess.run(command, capture_output=True, text=True, check=True); UI.success("'edge-tts' åº“å·²æˆåŠŸæ›´æ–°ï¼")
#     except Exception as e:
#         UI.error(f"è‡ªåŠ¨æ›´æ–°æ—¶å‘ç”Ÿé”™è¯¯: {e}")
#     UI.header("é‡è¦ï¼šè¯·é‡å¯å†…æ ¸ (å¿«æ·é”®: Ctrl + .) ç„¶åæŒ‰ F5 é‡æ–°è¿è¡Œç¨‹åºã€‚")
#     pygame.quit(); sys.exit(0)
# def run_async_task_in_thread(coro):
#     exception = None
#     def target():
#         nonlocal exception
#         try:
#             loop = asyncio.new_event_loop(); asyncio.set_event_loop(loop)
#             loop.run_until_complete(coro); loop.close()
#         except Exception as e: exception = e
#     thread = threading.Thread(target=target); thread.start(); thread.join()
#     if exception: raise exception
# async def generate_speech(text, voice, filename, retries=3):
#     for attempt in range(retries):
#         try:
#             communicate = edge_tts.Communicate(text, voice); await communicate.save(filename); return
#         except edge_tts.exceptions.NoAudioReceived as e:
#             if attempt < retries - 1: await asyncio.sleep(1)
#             else: raise e
# def speak_sentence(text_to_speak, voice_id):
#     cached_filepath = ""
#     try:
#         sentence_hash = hashlib.md5(text_to_speak.encode('utf-8')).hexdigest()
#         safe_voice_id = voice_id.replace(":", "-")
#         cached_filename = f"{sentence_hash}_{safe_voice_id}.mp3"
#         cached_filepath = os.path.join(CACHE_DIR, cached_filename)
#         generated_new_file = False
#         if not os.path.exists(cached_filepath) or os.path.getsize(cached_filepath) == 0:
#             UI.info("... æ­£åœ¨ç”Ÿæˆé«˜è´¨é‡è¯­éŸ³ ...")
#             speech_coroutine = generate_speech(text_to_speak, voice_id, cached_filepath)
#             run_async_task_in_thread(speech_coroutine)
#             if not os.path.exists(cached_filepath) or os.path.getsize(cached_filepath) == 0: return False
#             generated_new_file = True
#         pygame.mixer.music.load(cached_filepath); pygame.mixer.music.play(); UI.info("... ğŸ”Š æ­£åœ¨æœ—è¯» ...")
#         while pygame.mixer.music.get_busy(): time.sleep(0.1)
#         pygame.mixer.music.unload()
#         return 'GENERATED' if generated_new_file else 'CACHED'
#     except (WSServerHandshakeError, edge_tts.exceptions.NoAudioReceived, Exception) as e:
#         error_str = str(e).lower()
#         if "401" in error_str or "unauthorized" in error_str or ("status" in dir(e) and hasattr(e, 'status') and e.status == 401):
#             raise UnauthorizedError(f"Original error: {e}") from e
#         UI.error(f"å‘ç”Ÿç½‘ç»œæˆ–æ’­æ”¾é”™è¯¯: {e}")
#         if isinstance(e, pygame.error) and cached_filepath and os.path.exists(cached_filepath): os.remove(cached_filepath)
#         return False
# def find_country_by_code(user_input, code_map):
#     if not user_input: return None
#     return code_map.get(user_input.upper())

# def cleanup_on_exit(final_index, sentences):
#     pygame.quit()
#     UI.info("Pygame Mixer å·²è¢«å¸è½½ã€‚")
#     if not sentences or final_index >= len(sentences):
#         UI.success("æ‰€æœ‰å¥å­å·²å®Œæˆï¼Œç¨‹åºæ­£å¸¸ç»“æŸã€‚")
#         for f in [STATE_FILE, LEFTOVER_FILE]:
#             if os.path.exists(f): os.remove(f)
#         if os.path.exists(CACHE_DIR):
#             try: shutil.rmtree(CACHE_DIR); UI.info(f"éŸ³é¢‘ç¼“å­˜ç›®å½• '{CACHE_DIR}' å·²æˆåŠŸåˆ é™¤ã€‚")
#             except Exception as e: UI.error(f"æ¸…ç†ç¼“å­˜æ—¶å‘ç”Ÿé”™è¯¯: {e}")
#     else:
#         UI.info("ç¨‹åºå·²é€€å‡ºã€‚")
#         unread_sentences = sentences[final_index:]
#         if unread_sentences:
#             with open(LEFTOVER_FILE, 'w', encoding='utf-8') as f:
#                 for sentence in unread_sentences: f.write(sentence + '\n')
#             UI.info(f"å·²å°† {len(unread_sentences)} ä¸ªæœªè¯»å¥å­ä¿å­˜åˆ° '{LEFTOVER_FILE}'ã€‚")

# def check_and_highlight_spelling(original_sentence, user_spelling):
#     translator = str.maketrans('', '', string.punctuation)
#     original_words = [word.translate(translator).lower() for word in original_sentence.split()]
#     user_words = [word.translate(translator).lower() for word in user_spelling.split()]
#     matcher = difflib.SequenceMatcher(None, original_words, user_words)
#     is_correct = True
#     highlighted_parts = []
#     original_sentence_words = original_sentence.split()
#     for tag, i1, i2, j1, j2 in matcher.get_opcodes():
#         original_chunk = " ".join(original_sentence_words[i1:i2])
#         if tag == 'equal': highlighted_parts.append(original_chunk)
#         else:
#             is_correct = False
#             if original_chunk:
#                 highlighted_parts.append(f"{bcolors.RED}({original_chunk}){bcolors.ENDC}")
#     highlighted_string = " ".join(highlighted_parts)
#     return is_correct, highlighted_string

# def save_spelling_error_sentence(sentence):
#     if not sentence: return
#     try:
#         existing_errors = []
#         if os.path.exists(SPELLING_ERROR_FILE):
#             with open(SPELLING_ERROR_FILE, 'r', encoding='utf-8') as f:
#                 existing_errors = [line.strip() for line in f]
#         if sentence in existing_errors:
#             UI.info(f"å¥å­ '{sentence[:30]}...' å·²å­˜åœ¨äºé”™è¯¯æ–‡ä»¶ä¸­ã€‚")
#             return
#         with open(SPELLING_ERROR_FILE, 'a', encoding='utf-8') as f:
#             f.write(sentence + '\n')
#         UI.info(f"å·²å°†é”™è¯¯å¥å­ '{sentence[:30]}...' è®°å½•åˆ° {SPELLING_ERROR_FILE}")
#     except Exception as e:
#         UI.error(f"ä¿å­˜æ‹¼å†™é”™è¯¯æ—¶å‘ç”Ÿé”™è¯¯: {e}")

# def print_available_countries(available_voices, code_map):
#     print(f"ğŸ¤ {bcolors.CYAN}ä»¥ä¸‹æ˜¯å½“å‰å¯ç”¨çš„å›½å®¶/åœ°åŒºåŠå…¶ä»£ç ï¼š{bcolors.ENDC}")
#     available_countries = sorted(available_voices.keys())
#     if not available_countries:
#         UI.info("æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„å›½å®¶ã€‚")
#         UI.separator()
#         return

#     max_len = max(len(c) for c in available_countries)
#     num_columns = 2
#     while len(available_countries) % num_columns != 0:
#         available_countries.append("")
#     num_rows = len(available_countries) // num_columns
    
#     for i in range(num_rows):
#         row_items = []
#         for j in range(num_columns):
#             country = available_countries[i + j * num_rows]
#             if country:
#                 codes = [k for k, v in code_map.items() if v == country]
#                 code_str = "/".join(codes)
#                 row_items.append(f"{bcolors.GREEN}{code_str:<5}{bcolors.ENDC} - {country:<{max_len}}")
#         print(" | ".join(row_items))
#     UI.separator()

# def create_voice_map_dynamically(code_map, fallback_voices):
#     UI.info("ğŸŒ æ­£åœ¨åŠ¨æ€è·å–æœ€æ–°çš„è¯­éŸ³åˆ—è¡¨...")
#     UI.separator()
#     voices_by_country_dynamic = {}
#     async def fetch_and_build():
#         voices = await edge_tts.list_voices()
#         for voice in voices:
#             locale = voice.get('Locale', '')
#             parts = locale.split('-')
#             if len(parts) >= 2:
#                 country_code = parts[1]
#                 country_name = code_map.get(country_code.upper())
#                 if country_name:
#                     if country_name not in voices_by_country_dynamic:
#                         voices_by_country_dynamic[country_name] = []
#                     voices_by_country_dynamic[country_name].append(voice['Name'])
#     try:
#         run_async_task_in_thread(fetch_and_build())
#     except Exception as e:
#         UI.error(f"åŠ¨æ€è·å–è¯­éŸ³åˆ—è¡¨æ—¶å‘ç”Ÿé”™è¯¯: {e}")
#         UI.info("å°†ä½¿ç”¨å†…ç½®çš„å¤‡ç”¨è¯­éŸ³åˆ—è¡¨ã€‚")
#         UI.separator()
#         return fallback_voices
#     if not voices_by_country_dynamic:
#         UI.error("æœªèƒ½åŠ¨æ€è·å–åˆ°ä»»ä½•è¯­éŸ³ï¼Œå°†ä½¿ç”¨å†…ç½®çš„å¤‡ç”¨è¯­éŸ³åˆ—è¡¨ã€‚")
#         UI.separator()
#         return fallback_voices
    
#     UI.success("æˆåŠŸæ„å»ºäº†æœ€æ–°çš„è¯­éŸ³åº“ï¼")
#     UI.separator()
#     print_available_countries(voices_by_country_dynamic, code_map)
#     return voices_by_country_dynamic

# # ==============================================================================
# # ç¬¬2éƒ¨åˆ†ï¼šåœ¨çº¿è¯å…¸åº”ç”¨
# # ==============================================================================
# DICT_EXCEL_PATH = "C:/Users/Administrator/Desktop/è‹±å›½è€é¼ /ç†Ÿè¯.xlsx"; DICT_SHEET_NAME = "Sheet1"; WORD_CACHE_FILE = "word_cache.txt"

# # <<< --- ä»è¿™é‡Œå¼€å§‹æ·»åŠ éŸ¦æ°è¯å…¸ä»£ç  --- >>>
# # --- éŸ¦æ°è¯å…¸ API é…ç½® ---
# MW_API_KEYS = [
#     "aac6ea0e-417c-4eaf-ac85-0dc8f8a6ba13",
#     "93b2ec9c-d00c-4517-810a-ad2f8853fdfc",
# ]
# current_mw_api_key_index = 0

# def get_current_mw_api_key():
#     global current_mw_api_key_index
#     if not MW_API_KEYS: return None
#     return MW_API_KEYS[current_mw_api_key_index]

# def switch_to_next_mw_api_key():
#     global current_mw_api_key_index
#     if len(MW_API_KEYS) <= 1: return
#     previous_index = current_mw_api_key_index
#     current_mw_api_key_index = (current_mw_api_key_index + 1) % len(MW_API_KEYS)
#     UI.info(f"ğŸ”„ API Key åˆ‡æ¢: ...{MW_API_KEYS[previous_index][-6:]} -> ...{get_current_mw_api_key()[-6:]}")

# def print_mw_rate_limit_info(headers):
#     limit = headers.get('X-RateLimit-Limit')
#     remaining = headers.get('X-RateLimit-Remaining')
#     if limit and remaining:
#         UI.info(f"ğŸ“Š éŸ¦æ°è¯å…¸APIä½¿ç”¨æƒ…å†µ (Key ...{get_current_mw_api_key()[-6:]}): å‰©ä½™ {remaining} / {limit} æ¬¡è¯·æ±‚ã€‚")
#         sys.stdout.flush()
#         if int(remaining) <= 1:
#             switch_to_next_mw_api_key()

# def get_word_definition_merriam(word):
#     api_key = get_current_mw_api_key()
#     if not api_key:
#         UI.error("éŸ¦æ°è¯å…¸API Keyåˆ—è¡¨ä¸ºç©ºã€‚")
#         return False
#     url = f"https://www.dictionaryapi.com/api/v3/references/collegiate/json/{word}?key={api_key}"
#     print(f"ğŸ“š {bcolors.CYAN}æ­£åœ¨é€šè¿‡éŸ¦æ°è¯å…¸æŸ¥è¯¢: {word}{bcolors.ENDC}")
#     try:
#         response = requests.get(url, timeout=10)
#         print_mw_rate_limit_info(response.headers)
#         response.raise_for_status()
#         data = response.json()
#         if not data or not isinstance(data[0], dict):
#             suggestions = data if isinstance(data, list) and all(isinstance(i, str) for i in data) else []
#             UI.error(f"éŸ¦æ°è¯å…¸ä¸­æ²¡æœ‰æ‰¾åˆ°å•è¯ '{word}'ã€‚")
#             if suggestions: UI.info(f"æ‹¼å†™å»ºè®®: {', '.join(suggestions)}")
#             return False
#         found_definition = False
#         print(f"å•è¯: {bcolors.GREEN}{word.capitalize()}{bcolors.ENDC}")
#         for entry in data:
#             if isinstance(entry, dict) and entry.get('meta', {}).get('id', '').split(':')[0].lower() == word.lower():
#                 if 'fl' in entry: print(f"\nã€{bcolors.CYAN}{entry['fl']}{bcolors.ENDC}ã€‘")
#                 if 'shortdef' in entry:
#                     for i, definition in enumerate(entry['shortdef']):
#                         clean_def = definition.replace('{bc}', '').replace('{it}', '').replace('{/it}', '')
#                         print(f"  {i+1}. {clean_def}")
#                     found_definition = True
#         return found_definition
#     except requests.exceptions.RequestException as e:
#         UI.error(f"ç½‘ç»œè¿æ¥é”™è¯¯: {e}")
#     except Exception as e:
#         UI.error(f"è§£æéŸ¦æ°è¯å…¸æ•°æ®æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
#     return False
# # <<< --- åœ¨è¿™é‡Œç»“æŸæ·»åŠ  --- >>>


# def save_word_to_cache(word, cache_filepath):
#     try:
#         with open(cache_filepath, 'a', encoding='utf-8') as f: f.write(word + '\n')
#         UI.success(f"å•è¯ '{word}' å·²ç¼“å­˜ï¼Œå°†åœ¨ä¸‹æ¬¡å¯åŠ¨æ—¶ä¿å­˜ã€‚")
#     except Exception as e: UI.error(f"ç¼“å­˜å•è¯æ—¶å‘ç”Ÿé”™è¯¯: {e}")
# def _write_words_to_excel_core(words, filepath, sheetname):
#     if not words: return True
#     try:
#         directory = os.path.dirname(filepath)
#         if directory and not os.path.exists(directory): os.makedirs(directory)
#         workbook = openpyxl.load_workbook(filepath) if os.path.exists(filepath) else openpyxl.Workbook()
#         if sheetname in workbook.sheetnames: sheet = workbook[sheetname]
#         else:
#             sheet = workbook.create_sheet(sheetname) if len(workbook.sheetnames) > 0 and workbook.sheetnames[0] != 'Sheet' else workbook.active
#             sheet.title = sheetname
#         target_row = 1
#         while sheet.cell(row=target_row, column=1).value is not None: target_row += 1
#         for word in words: sheet.cell(row=target_row, column=1, value=word); target_row += 1
#         workbook.save(filepath)
#         UI.success(f"æˆåŠŸï¼{len(words)} ä¸ªç¼“å­˜çš„å•è¯å·²ä¿å­˜åˆ°Excelã€‚")
#         return True
#     except PermissionError: UI.error(f"æ— æ³•å†™å…¥Excelï¼è¯·å…ˆå…³é—­æ­£åœ¨æ‰“å¼€çš„æ–‡ä»¶ '{filepath}'ã€‚"); return False
#     except Exception as e: UI.error(f"å†™å…¥Excelæ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}"); return False

# def get_word_definition(word):
#     print(f"ğŸ“š {bcolors.CYAN}æ­£åœ¨æŸ¥è¯¢å•è¯: {word}{bcolors.ENDC}")
#     url = f"https://api.dictionaryapi.dev/api/v2/entries/en/{word}"
#     for attempt in range(3):
#         try:
#             response = requests.get(url, timeout=10)
#             if response.status_code == 200:
#                 data = response.json()[0]
#                 print(f"å•è¯: {bcolors.GREEN}{data['word']}{bcolors.ENDC}")
#                 for meaning in data['meanings']:
#                     print(f"\nã€{bcolors.CYAN}{meaning['partOfSpeech']}{bcolors.ENDC}ã€‘")
#                     for i, definition in enumerate(meaning['definitions']):
#                         print(f"{i+1}. {definition['definition']}")
#                 return True
#             elif response.status_code == 404:
#                 UI.error(f"æŠ±æ­‰ï¼Œè¯å…¸ä¸­æ²¡æœ‰æ‰¾åˆ°å•è¯ '{word}'ã€‚")
#                 return False
#             else:
#                 UI.error(f"æŸ¥è¯¢å‡ºé”™ï¼ŒçŠ¶æ€ç : {response.status_code} (å°è¯• {attempt + 1}/3)")
#         except requests.exceptions.RequestException as e:
#             UI.error(f"ç½‘ç»œè¿æ¥é”™è¯¯: {e} (å°è¯• {attempt + 1}/3)")
#         if attempt < 2:
#             UI.info("å°†åœ¨1ç§’åé‡è¯•...")
#             time.sleep(1)
#     UI.error("æŸ¥è¯¢å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ã€‚")
#     return False

# # ==============================================================================
# # ç¬¬3éƒ¨åˆ†ï¼šåº”ç”¨åˆ‡æ¢é€»è¾‘
# # ==============================================================================
# speech_app_initialized = False; sentences = []; current_index = 0
# default_country = "United States"; last_used_voice = None; word_to_lookup_on_switch = None
# def initialize_speech_app():
#     global sentences, current_index, speech_app_initialized
#     if speech_app_initialized: return True
#     UI.info("æ­£åœ¨åˆå§‹åŒ–è¯­éŸ³æœ—è¯»ç¨‹åº...")
#     load_from_excel = True
#     if os.path.exists(LEFTOVER_FILE) and os.path.getsize(LEFTOVER_FILE) > 0:
#         with open(LEFTOVER_FILE, 'r', encoding='utf-8') as f: leftover = [line.strip() for line in f if line.strip()]
#         if leftover:
#             UI.separator()
#             choice = UI.prompt(f"æ£€æµ‹åˆ°ä¸Šæ¬¡æœ‰ {len(leftover)} å¥æœªè¯»ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ(Y/n): ").strip().lower()
#             if choice in ['y', 'yes', '']: sentences = leftover; load_from_excel = False
#     if load_from_excel:
#         try:
#             df = pd.read_excel(SPEECH_EXCEL_PATH, header=None); raw = df.iloc[:, 0].tolist()
#             sentences = [str(s).strip().replace('\n', ' ') for s in raw if pd.notna(s) and str(s).strip()]
#             if not sentences: UI.error(f"Excelæ–‡ä»¶ '{SPEECH_EXCEL_PATH}' ä¸ºç©ºã€‚"); UI.separator(); return False
#             UI.success(f"æˆåŠŸä»Excelè¯»å– {len(sentences)} ä¸ªå¥å­å¹¶æ‰“ä¹±é¡ºåºã€‚")
#             random.shuffle(sentences)
#         except FileNotFoundError: UI.error(f"æ–‡ä»¶æœªæ‰¾åˆ° '{SPEECH_EXCEL_PATH}'ã€‚"); UI.separator(); return False
#         except Exception as e: UI.error(f"è¯»å–Excelæ—¶å‘ç”Ÿé”™è¯¯: {e}ã€‚"); UI.separator(); return False
#     start_index = 0
#     if os.path.exists(STATE_FILE):
#         try:
#             with open(STATE_FILE, 'r') as f: content = f.read().strip()
#             if content:
#                 saved_index_str, saved_hash = content.split('|')
#                 current_hash = hashlib.md5("".join(sentences).encode('utf-8')).hexdigest()
#                 if current_hash == saved_hash: start_index = int(saved_index_str)
#         except Exception: pass
#     current_index = start_index
#     UI.info(f"è¯­éŸ³æœ—è¯»å‡†å¤‡å°±ç»ªï¼Œå°†ä»ç¬¬ {current_index + 1} å¥å¼€å§‹ã€‚")
#     speech_app_initialized = True; return True

# def handle_spelling_session(sentence, voice):
#     typed_so_far = ""
#     while True:
#         print(f"\nâœï¸  å½“å‰å·²è¾“å…¥: {bcolors.CYAN}{typed_so_far}{bcolors.ENDC}")
#         prompt_text = "è¾“å…¥ '.' æäº¤, Enter é‡å¬, æˆ–ç»§ç»­è¾“å…¥: "
#         try:
#             user_action = UI.prompt(prompt_text)
#         except (KeyboardInterrupt, EOFError):
#              print("\n"); UI.error("æ‹¼å†™å·²å–æ¶ˆã€‚"); return None
#         if user_action == "":
#             UI.info("...é‡å¬éŸ³é¢‘..."); speak_sentence(sentence, voice); UI.separator(); continue
#         if user_action == ".":
#             return typed_so_far
#         if typed_so_far:
#             typed_so_far += " " + user_action
#         else:
#             typed_so_far = user_action

# def handle_speech_interaction():
#     global current_index, default_country, last_used_voice, sentences, voices_by_country, country_code_map
    
#     current_sentence = sentences[current_index]
    
#     print(f"ğŸ¤ {bcolors.CYAN}--- è¯­éŸ³æœ—è¯» ({current_index + 1}/{len(sentences)}) ---{bcolors.ENDC}")
#     print(f"   å¥å­: '{current_sentence}'")
    
#     played_successfully = False
    
#     if last_used_voice is None:
#         tried_voices_this_sentence = set()
#         voice_scores = load_voice_scores()
#         country_voices = voices_by_country.get(default_country, [])
#         candidate_voices = [v for v in country_voices if v != last_used_voice]
#         first_try_voice = random.choice(candidate_voices) if candidate_voices else (country_voices[0] if country_voices else None)
#         if first_try_voice:
#             tried_voices_this_sentence.add(first_try_voice)
#             try:
#                 UI.info(f"é¦–æ¬¡å°è¯• (éšæœºé€‰æ‹©ï¼Œæƒé‡: {voice_scores.get(first_try_voice, 0)}): {first_try_voice}")
#                 result = speak_sentence(current_sentence, first_try_voice)
#                 if result:
#                     if result == 'GENERATED': update_voice_score(first_try_voice, 1)
#                     last_used_voice = first_try_voice; played_successfully = True
#             except UnauthorizedError:
#                 UI.error(f"é¦–æ¬¡å°è¯•çš„å£°éŸ³ '{first_try_voice}' æˆæƒå¤±è´¥ã€‚å°†å¯åŠ¨å¥å£®æ¨¡å¼...")
#                 update_voice_score(first_try_voice, -1)
#         if not played_successfully:
#             def attempt_playback_robust(country, limit, is_fallback=False):
#                 nonlocal played_successfully; global last_used_voice
#                 stage_name = "åå¤‡" if is_fallback else "ä¸»"
#                 UI.info(f"{stage_name}é‡è¯• (åŸºäºæƒé‡): {country} (æœ€å¤š {limit} æ¬¡)...")
#                 for attempt in range(limit):
#                     voices_to_try = voices_by_country.get(country, [])
#                     prioritized_list = get_prioritized_voices(voices_to_try, voice_scores, tried_voices_this_sentence)
#                     if not prioritized_list: UI.error(f"{stage_name}å›½å®¶æ‰€æœ‰å¯ç”¨å£°éŸ³å‡å·²å°è¯•ã€‚"); return
#                     current_voice = prioritized_list[0]; tried_voices_this_sentence.add(current_voice)
#                     try:
#                         UI.info(f"å°è¯•{stage_name}å£°éŸ³ (æƒé‡: {voice_scores.get(current_voice, 0)}): {current_voice} ({attempt + 1}/{limit})")
#                         result = speak_sentence(current_sentence, current_voice)
#                         if result:
#                             if result == 'GENERATED': update_voice_score(current_voice, 1)
#                             last_used_voice = current_voice; played_successfully = True; return
#                     except UnauthorizedError:
#                         UI.error(f"å£°éŸ³ '{current_voice}' æˆæƒå¤±è´¥ã€‚"); update_voice_score(current_voice, -1); time.sleep(0.5)
#             attempt_playback_robust(default_country, PRIMARY_RETRY_LIMIT)
#             if not played_successfully: attempt_playback_robust(FALLBACK_COUNTRY, FALLBACK_RETRY_LIMIT, is_fallback=True)
#     else:
#         UI.info(f"é‡å¤æ’­æ”¾ (ä½¿ç”¨ç¼“å­˜å£°éŸ³ï¼Œæƒé‡: {load_voice_scores().get(last_used_voice, 0)}): {last_used_voice}")
#         result = speak_sentence(current_sentence, last_used_voice)
#         if result: played_successfully = True
#         else: UI.error(f"ç¼“å­˜æ–‡ä»¶æ’­æ”¾å¤±è´¥ï¼Œå°†å°è¯•é‡æ–°é€‰æ‹©å£°éŸ³ã€‚"); last_used_voice = None

#     if not played_successfully:
#         UI.error("æ’­æ”¾å¤±è´¥ï¼Œæ— æ³•ç»§ç»­ã€‚")
#         if last_used_voice is None: handle_auth_error_and_exit()
#         UI.separator()
#         return 'CONTINUE'

#     UI.separator()
#     prompt_text = "æŒ‡ä»¤: (s)å¥å­ (w)å•è¯, (.)ä¸‹ä¸€å¥, (l)ä¸Šä¸€å¥, (v)çœ‹è¯­éŸ³åº“, (z)æ¢äºº, (Enter)é‡å¬, (q)é€€å‡º: "
#     user_input = UI.prompt(prompt_text).strip()
#     lower_input = user_input.lower()

#     if lower_input == 's':
#         user_spelling = handle_spelling_session(sentence, last_used_voice)
#         if user_spelling is None: return 'CONTINUE'
#         is_correct, highlighted_string = check_and_highlight_spelling(current_sentence, user_spelling)
#         print(f"âœï¸  {bcolors.CYAN}--- æ‹¼å†™æ£€æŸ¥ç»“æœ ---{bcolors.ENDC}"); print(f"   ç»“æœ: {highlighted_string}")
#         if is_correct: UI.success("å¥å­æ‹¼å†™å®Œå…¨æ­£ç¡®ï¼")
#         else: UI.error("å¥å­æ‹¼å†™æœ‰è¯¯ã€‚"); save_spelling_error_sentence(current_sentence)
#         UI.separator()
#         return 'CONTINUE'
    
#     elif lower_input == 'w':
#         user_words_input = handle_spelling_session(current_sentence, last_used_voice)
#         if user_words_input is None: return 'CONTINUE'
#         translator = str.maketrans('', '', string.punctuation)
#         clean_original_words = {word.translate(translator).lower() for word in current_sentence.split()}
#         user_words = user_words_input.split()
#         all_found = True
#         not_found_words = []
#         for word in user_words:
#             if word.strip() and word.translate(translator).lower() not in clean_original_words:
#                 all_found = False
#                 not_found_words.append(word)
#         if all_found:
#             UI.success(f"å•è¯/è¯ç»„ '{user_words_input}' å‡å­˜åœ¨äºå¥å­ä¸­ï¼Œæ‹¼å†™æ­£ç¡®ï¼")
#         else:
#             UI.error(f"å•è¯ '{', '.join(not_found_words)}' ä¸åœ¨å¥å­ä¸­æˆ–æ‹¼å†™é”™è¯¯ã€‚")
#             save_spelling_error_sentence(current_sentence)
#         UI.separator()
#         return 'CONTINUE'

#     if lower_input in ['.', 'ã€‚', 'n']:
#         current_index += 1; last_used_voice = None
#     elif user_input == '': pass
#     elif lower_input == 'l':
#         current_index = max(0, current_index - 1); last_used_voice = None
#     elif lower_input == 'z': last_used_voice = None
#     elif lower_input == 'v':
#         print_available_countries(voices_by_country, country_code_map)
#     elif lower_input == 'q': return 'QUIT'
#     elif lower_input == 'm': return 'GOTO_MENU'
#     elif lower_input == '2': return 'SWITCH_TO_2'
#     else:
#         matched_country = find_country_by_code(user_input, country_code_map)
#         if matched_country:
#             default_country = matched_country; UI.info(f"å›½å®¶å·²åˆ‡æ¢åˆ°: {default_country}ã€‚"); last_used_voice = None
#         else:
#             return ('SWITCH_TO_2_WITH_WORD', user_input)
#     return 'CONTINUE'

# def prompt_for_error_rerun():
#     global sentences, current_index, speech_app_initialized
#     if not os.path.exists(SPELLING_ERROR_FILE) or os.path.getsize(SPELLING_ERROR_FILE) == 0:
#         return False
#     choice = UI.prompt(f"æ£€æµ‹åˆ° {SPELLING_ERROR_FILE} ä¸­æœ‰å†…å®¹ï¼Œæ˜¯å¦å¼€å§‹å¤ä¹ ï¼Ÿ (Y/n): ").strip().lower()
#     if choice in ['y', 'yes', '']:
#         UI.info(f"æ­£åœ¨ä» {SPELLING_ERROR_FILE} åŠ è½½å¤ä¹ å†…å®¹...")
#         try:
#             with open(SPELLING_ERROR_FILE, 'r', encoding='utf-8') as f:
#                 error_content = list(dict.fromkeys([line.strip() for line in f if line.strip()]))
#             if not error_content:
#                 os.remove(SPELLING_ERROR_FILE); return False
#             sentences = error_content
#             current_index = 0
#             speech_app_initialized = True
#             random.shuffle(sentences)
#             UI.success(f"åŠ è½½æˆåŠŸï¼å°†å¼€å§‹å¤ä¹  {len(sentences)} ä¸ªé”™è¯¯é¡¹ç›®ã€‚")
#             os.remove(SPELLING_ERROR_FILE)
#             UI.separator()
#             return True
#         except Exception as e:
#             UI.error(f"ä»é”™è¯¯æ–‡ä»¶åŠ è½½æ—¶å‡ºé”™: {e}")
#             if os.path.exists(SPELLING_ERROR_FILE): os.remove(SPELLING_ERROR_FILE)
#             UI.separator()
#             return False
#     else:
#         UI.info(f"å¥½çš„ï¼Œå°†æ¸…ç©ºå¹¶åˆ é™¤ {SPELLING_ERROR_FILE}ã€‚")
#         if os.path.exists(SPELLING_ERROR_FILE): os.remove(SPELLING_ERROR_FILE)
#         UI.separator()
#         return False

# # ==============================================================================
# # ç¬¬4éƒ¨åˆ†ï¼šä¸»æ§åˆ¶å™¨
# # ==============================================================================
# def process_word_cache_on_startup():
#     if not os.path.exists(WORD_CACHE_FILE) or os.path.getsize(WORD_CACHE_FILE) == 0: return
#     UI.info("æ­£åœ¨å¤„ç†å•è¯ç¼“å­˜...")
#     UI.separator()
#     try:
#         # 1. å…ˆè¯»å–å½“å‰Excelä¸­çš„å•è¯æ€»æ•°
#         try:
#             workbook = openpyxl.load_workbook(DICT_EXCEL_PATH)
#             sheet = workbook[DICT_SHEET_NAME]
#             current_total = sheet.max_row
#         except (FileNotFoundError, KeyError):
#             current_total = 0
        
#         # 2. è¯»å–ç¼“å­˜æ–‡ä»¶
#         with open(WORD_CACHE_FILE, 'r', encoding='utf-8') as f:
#             words_to_save = list(dict.fromkeys([line.strip() for line in f if line.strip()]))
        
#         if not words_to_save: 
#             os.remove(WORD_CACHE_FILE)
#             UI.info(f"å½“å‰ç†Ÿè¯åº“ '{os.path.basename(DICT_EXCEL_PATH)}' ä¸­å…±æœ‰ {current_total} ä¸ªå•è¯ã€‚")
#             UI.separator()
#             return

#         # 3. å†™å…¥æ–°å•è¯
#         success = _write_words_to_excel_core(words_to_save, DICT_EXCEL_PATH, DICT_SHEET_NAME)
        
#         # 4. æŠ¥å‘Šç»“æœ
#         if success:
#             new_total = current_total + len(words_to_save)
#             UI.info("å•è¯ç¼“å­˜å·²æ¸…ç©ºã€‚")
#             UI.success(f"å½“å‰ç†Ÿè¯åº“ '{os.path.basename(DICT_EXCEL_PATH)}' ä¸­å…±æœ‰ {new_total} ä¸ªå•è¯ã€‚")
#             os.remove(WORD_CACHE_FILE)
#         else:
#             UI.error("å†™å…¥Excelå¤±è´¥ã€‚ç¼“å­˜æ–‡ä»¶å·²ä¿ç•™ï¼Œä¸‹æ¬¡å¯åŠ¨å°†é‡è¯•ã€‚")

#     except Exception as e:
#         UI.error(f"å¤„ç†å•è¯ç¼“å­˜æ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯: {e}")
#         UI.info("ç¼“å­˜æ–‡ä»¶å·²ä¿ç•™ï¼Œä¸‹æ¬¡å¯åŠ¨å°†é‡è¯•ã€‚")
#     UI.separator()

# def run_dictionary_loop(initial_word=None):
#     UI.header("åœ¨çº¿è¯å…¸")
#     UI.info(f"æŸ¥åˆ°çš„å•è¯å°†æè®®ä¿å­˜åˆ°: {DICT_EXCEL_PATH}")
#     UI.info("å…¨å±€æŒ‡ä»¤: '1'è¯­éŸ³æœ—è¯» | 'm'ä¸»èœå• | 'q'é€€å‡º")
#     UI.separator()
#     word_to_save = None
#     if initial_word:
#         found = False
#         if DICTIONARY_CHOICE == '1':
#             found = get_word_definition(initial_word)
#         elif DICTIONARY_CHOICE == '2':
#             found = get_word_definition_merriam(initial_word)
#         if found: word_to_save = initial_word
#         UI.separator()
        
#     while True:
#         prompt_text = f"æ˜¯å¦ä¿å­˜å•è¯ '{word_to_save}'? (Enter=ä¿å­˜, æˆ–è¾“å…¥æ–°å•è¯/æŒ‡ä»¤): " if word_to_save else "è¯·è¾“å…¥å•è¯ (æˆ–å…¨å±€æŒ‡ä»¤): "
#         user_input = UI.prompt(prompt_text).strip()
#         if word_to_save and user_input == '':
#             save_word_to_cache(word_to_save, WORD_CACHE_FILE); word_to_save = None; UI.separator(); continue
#         lower_input = user_input.lower()
#         if lower_input in ['1', 'm', 'q']:
#             if word_to_save: UI.info(f"æ“ä½œå–æ¶ˆï¼Œæœªä¿å­˜å•è¯ '{word_to_save}'ã€‚"); word_to_save = None
#             if lower_input == '1': return 'SWITCH_TO_1'
#             if lower_input == 'm': return 'GOTO_MENU'
#             if lower_input == 'q': return 'QUIT'
#         if word_to_save: UI.info(f"æ“ä½œå–æ¶ˆï¼Œæœªä¿å­˜å•è¯ '{word_to_save}'ã€‚"); word_to_save = None
#         if not user_input: continue
        
#         found = False
#         if DICTIONARY_CHOICE == '1':
#             found = get_word_definition(user_input)
#         elif DICTIONARY_CHOICE == '2':
#             found = get_word_definition_merriam(user_input)
        
#         if found:
#             word_to_save = user_input
#         UI.separator()

# if __name__ == "__main__":
#     DICTIONARY_CHOICE = None
#     def choose_dictionary():
#         global DICTIONARY_CHOICE
#         while DICTIONARY_CHOICE not in ['1', '2']:
#             UI.header("è¯å…¸é€‰æ‹©")
#             print("è¯·é€‰æ‹©æ‚¨æƒ³ä½¿ç”¨çš„è‹±è‹±è¯å…¸ï¼š")
#             print("1. DictionaryAPI (å…è´¹, ç®€å•)")
#             print("2. Merriam-Webster (éŸ¦æ°è¯å…¸, ä¸“ä¸š, éœ€API Key)")
#             UI.separator()
#             DICTIONARY_CHOICE = UI.prompt("è¯·è¾“å…¥é€‰æ‹© (1 æˆ– 2): ").strip()
#     choose_dictionary()

#     voices_by_country = create_voice_map_dynamically(country_code_map, voices_by_country)
#     process_word_cache_on_startup()
#     current_app = 'menu'; user_quit = False
#     try:
#         while not user_quit:
#             if current_app == 'menu':
#                 UI.header("ä¸»èœå•")
#                 print("1. äº¤äº’å¼è¯­éŸ³æœ—è¯»ç¨‹åº")
#                 print("2. åœ¨çº¿è¯å…¸æŸ¥è¯¢")
#                 print("q. é€€å‡ºç¨‹åº")
#                 UI.separator()
#                 choice = UI.prompt("è¯·è¾“å…¥ä½ çš„é€‰æ‹© (1, 2, æˆ– q): ").strip().lower()
#                 if choice == '1': current_app = '1'
#                 elif choice == '2': current_app = '2'
#                 elif choice == 'q':
#                     if prompt_for_error_rerun():
#                         current_app = '1'; continue
#                     else: user_quit = True
#                 else: UI.error("æ— æ•ˆçš„é€‰æ‹©ã€‚"); UI.separator()
#             elif current_app == '1':
#                 if not initialize_speech_app():
#                     UI.error("åˆå§‹åŒ–å¤±è´¥ï¼Œè¿”å›ä¸»èœå•ã€‚"); current_app = 'menu'; UI.separator(); continue
#                 if current_index >= len(sentences):
#                     if prompt_for_error_rerun(): continue
#                     UI.success("æ‰€æœ‰å¥å­å·²æœ—è¯»å®Œæ¯•ï¼è¿”å›ä¸»èœå•ã€‚"); UI.separator()
#                     speech_app_initialized = False; sentences = []; current_app = 'menu'
#                     for f in [STATE_FILE, LEFTOVER_FILE]:
#                         if os.path.exists(f): os.remove(f)
#                     continue
#                 action = handle_speech_interaction()
#                 if isinstance(action, tuple) and action[0] == 'SWITCH_TO_2_WITH_WORD':
#                     word_to_lookup_on_switch = action[1]; current_app = '2'
#                 elif action == 'SWITCH_TO_2': current_app = '2'
#                 elif action == 'GOTO_MENU': current_app = 'menu'
#                 elif action == 'QUIT':
#                     if prompt_for_error_rerun():
#                         current_app = '1'; continue
#                     else: user_quit = True
#             elif current_app == '2':
#                 if word_to_lookup_on_switch:
#                     action = run_dictionary_loop(initial_word=word_to_lookup_on_switch); word_to_lookup_on_switch = None
#                 else: action = run_dictionary_loop()
#                 if action == 'SWITCH_TO_1': current_app = '1'
#                 elif action == 'GOTO_MENU': current_app = 'menu'
#                 elif action == 'QUIT': user_quit = True
#     finally:
#         UI.info("æ­£åœ¨æ‰§è¡Œé€€å‡ºæ¸…ç†ç¨‹åº...")
#         cleanup_on_exit(current_index, sentences)
#         UI.info("ç¨‹åºå·²å®Œå…¨å…³é—­ã€‚")
#         UI.separator()





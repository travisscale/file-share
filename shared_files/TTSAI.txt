# =-============================================================================
# ç¬¬0éƒ¨åˆ†ï¼šå¯¼å…¥åº“ä¸å…¨å±€åˆå§‹åŒ–
# ==============================================================================
import edge_tts
from gtts import gTTS
import pygame
import asyncio
import os
import pandas as pd
import sys
import random
import time
import threading
from thefuzz import process
import hashlib
import shutil
import subprocess
import requests
import openpyxl
import json
import difflib
import string
import re
from datetime import datetime # Import datetime for timestamping

TTS_ENGINE = None
APP_MODE = None 

try:
    from aiohttp.client_exceptions import WSServerHandshakeError
except ImportError:
    class WSServerHandshakeError(Exception): pass

class UnauthorizedError(Exception):
    pass

class bcolors:
    RED = '\033[91m'; GREEN = '\033[92m'; YELLOW = '\033[93m'; BLUE = '\033[94m'; CYAN = '\033[96m'; ENDC = '\033[0m'
class UI:
    WIDTH = 60
    @staticmethod
    def separator(): print(bcolors.CYAN + "-" * UI.WIDTH + bcolors.ENDC)
    @staticmethod
    def header(text): width = 40; print(bcolors.BLUE + "#" * width + f"\n###{(text.center(width - 6))}###\n" + "#" * width + bcolors.ENDC); UI.separator()
    @staticmethod
    def prompt(text): response = input(f"{bcolors.YELLOW}â“ {text}{bcolors.ENDC}"); UI.separator(); return response
    @staticmethod
    def info(text): print(f"{bcolors.YELLOW}â„¹ï¸  {text}{bcolors.ENDC}")
    @staticmethod
    def success(text): print(f"{bcolors.GREEN}âœ… {text}{bcolors.ENDC}")
    @staticmethod
    def error(text): print(f"{bcolors.RED}âŒ {text}{bcolors.ENDC}")

pygame.mixer.init()
UI.success("Pygame Mixer å·²æˆåŠŸåˆå§‹åŒ–ã€‚")
UI.separator()

# ==============================================================================
# ç¬¬1éƒ¨åˆ†ï¼šè¯­éŸ³æœ—è¯»åº”ç”¨ (ä»£ç 1) - æ ¸å¿ƒå‡½æ•°ä¸é…ç½®
# ==============================================================================
CACHE_DIR = "audio_cache"
STATE_FILE = "run_state.txt"
LEFTOVER_FILE = "leftover_sentences.txt"
MODIFIED_STATE_FILE = "modified_run_state.json" # è™½ç„¶ä¸å†ä½¿ç”¨ï¼Œä½†ä¿ç•™ä»¥å¤‡æ¸…ç†

SPELLING_ERROR_FILE = "spelling_errors.txt"
MODIFIED_SPELLING_ERROR_FILE = "modified_spelling_errors.txt"

SPEECH_EXCEL_PATH = r'C:\Users\Administrator\Desktop\è‹±å›½è€é¼ \å·¥ä½œç°¿1.xlsm'
MODIFIED_BLIND_SPOT_LOG_PATH = r'C:\Users\Administrator\.spyder-py3\blind_spotting_log.xlsx'
ORIGINAL_BLIND_SPOT_LOG_PATH = "blind_spotting_log.xlsx"

# !!! é‡è¦: è¯·å°† "YourDictionaryFile.xlsm" æ›¿æ¢ä¸ºæ‚¨å®é™…çš„æœ¬åœ°è¯å…¸æ–‡ä»¶å !!!
LOCAL_DICT_DATA_PATH = r'C:\Users\Administrator\Desktop\è‹±å›½è€é¼ \æ•°æ®åº“.xlsm'

os.makedirs(CACHE_DIR, exist_ok=True)

VOICE_SCORE_FILE = "voice_scores.json"
PRIMARY_RETRY_LIMIT = 50
FALLBACK_RETRY_LIMIT = 10
FALLBACK_COUNTRY = "United Kingdom"
voices_by_country = { "United Kingdom": ["en-GB-RyanNeural", "en-GB-SoniaNeural"], "United States": ["en-US-JennyNeural", "en-US-GuyNeural"] }
country_code_map = { "AU": "Australia", "GB": "United Kingdom", "UK": "United Kingdom", "US": "United States", "CA": "Canada", "IN": "India", "IE": "Ireland", "ZA": "South Africa", "CN": "China (Mainland)"}

GTTS_VOICES = {
    "United States": {"lang": "en", "tld": "com", "desc": "ç¾å¼å£éŸ³"}, "United Kingdom": {"lang": "en", "tld": "co.uk", "desc": "è‹±å¼å£éŸ³"},
    "Australia": {"lang": "en", "tld": "com.au", "desc": "æ¾³å¤§åˆ©äºšå£éŸ³"}, "Canada": {"lang": "en", "tld": "ca", "desc": "åŠ æ‹¿å¤§å£éŸ³"},
    "India": {"lang": "en", "tld": "co.in", "desc": "å°åº¦å£éŸ³"}, "Ireland": {"lang": "en", "tld": "ie", "desc": "çˆ±å°”å…°å£éŸ³"},
    "South Africa": {"lang": "en", "tld": "co.za", "desc": "å—éå£éŸ³"}, "China (Mainland)": {"lang": "zh-cn", "tld": "com.hk", "desc": "ä¸­æ–‡æ™®é€šè¯"}
}

modified_playback_list = []
modified_current_index = 0
modified_app_initialized = False

def get_archive_sheet(workbook):
    """Gets or creates the 'Archive' sheet in the workbook."""
    archive_sheet_name = "Archive"
    if archive_sheet_name in workbook.sheetnames:
        return workbook[archive_sheet_name]
    else:
        archive_sheet = workbook.create_sheet(archive_sheet_name)
        archive_sheet.append(["Sentence", "Voice Info", "User Input", "Deletion Timestamp"])
        return archive_sheet

def delete_specific_blind_spot_from_excel(filepath, sentence, user_input):
    try:
        workbook = openpyxl.load_workbook(filepath)
        sheet = workbook.active
        archive_sheet = get_archive_sheet(workbook)
        row_deleted = False
        
        for row_index in range(sheet.max_row, 1, -1):
            sentence_cell = sheet.cell(row=row_index, column=1).value
            voice_info_cell = sheet.cell(row=row_index, column=2).value
            user_input_cell = sheet.cell(row=row_index, column=3).value
            
            if (sentence_cell and str(sentence_cell).strip() == sentence and
                user_input_cell and str(user_input_cell).strip() == user_input):
                
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                archive_sheet.append([sentence_cell, voice_info_cell, user_input_cell, timestamp])
                
                sheet.delete_rows(row_index)
                row_deleted = True
                break
        
        if row_deleted:
            workbook.save(filepath)
            UI.success(f"å·²æˆåŠŸå­˜æ¡£å¹¶åˆ é™¤æŒ‡å®šçš„æ‰«ç›²æ¡ç›®ã€‚")
            return True
        else:
            UI.info("åœ¨æ–‡ä»¶ä¸­æœªæ‰¾åˆ°å®Œå…¨åŒ¹é…çš„æ¡ç›®è¿›è¡Œåˆ é™¤ã€‚")
            return False
    except PermissionError:
        UI.error(f"å­˜æ¡£/åˆ é™¤è¡Œå¤±è´¥ï¼è¯·å…ˆå…³é—­æ­£åœ¨æ‰“å¼€çš„Excelæ–‡ä»¶ '{filepath}'ã€‚")
        return False
    except Exception as e:
        UI.error(f"å­˜æ¡£/åˆ é™¤Excelè¡Œæ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
        return False

def delete_multiple_rows_from_excel(filepath, rows_to_delete):
    if not rows_to_delete:
        return True
    try:
        workbook = openpyxl.load_workbook(filepath)
        sheet = workbook.active
        for row_num in sorted(rows_to_delete, reverse=True):
            sheet.delete_rows(row_num)
        workbook.save(filepath)
        UI.success(f"å¯åŠ¨æ¸…ç†å®Œæˆï¼šå·²ä» '{os.path.basename(filepath)}' åˆ é™¤äº† {len(rows_to_delete)} ä¸ªæœªåŒ¹é…çš„è¡Œã€‚")
        return True
    except PermissionError:
        UI.error(f"æ¸…ç†æœªåŒ¹é…è¡Œå¤±è´¥ï¼è¯·å…ˆå…³é—­æ­£åœ¨æ‰“å¼€çš„Excelæ–‡ä»¶ '{filepath}'ã€‚")
        return False
    except Exception as e:
        UI.error(f"æ¸…ç†æœªåŒ¹é…è¡Œæ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
        return False

def load_voice_scores():
    if not os.path.exists(VOICE_SCORE_FILE): return {}
    try:
        with open(VOICE_SCORE_FILE, 'r', encoding='utf-8') as f: return json.load(f)
    except (json.JSONDecodeError, IOError): return {}
def save_voice_scores(scores):
    try:
        with open(VOICE_SCORE_FILE, 'w', encoding='utf-8') as f: json.dump(scores, f, indent=4)
    except IOError: UI.error(f"æ— æ³•å†™å…¥å£°éŸ³è¯„åˆ†æ–‡ä»¶ {VOICE_SCORE_FILE}")
def update_voice_score(voice, change):
    if '|' in voice: return
    scores = load_voice_scores(); scores[voice] = scores.get(voice, 0) + change; save_voice_scores(scores)
def get_prioritized_voices(country_voices, scores, tried_voices):
    available_voices = [v for v in country_voices if v not in tried_voices]
    return sorted(available_voices, key=lambda v: scores.get(v, 0), reverse=True)
def handle_auth_error_and_exit():
    UI.error("æ‰€æœ‰é‡è¯•å°è¯•å‡å¤±è´¥ã€‚è¿™å¾ˆå¯èƒ½æ˜¯å› ä¸ºåº“ç‰ˆæœ¬è¿‡æ—§ã€‚æ­£åœ¨å°è¯•è‡ªåŠ¨æ›´æ–°...");
    try:
        command = [sys.executable, "-m", "pip", "install", "--upgrade", "edge-tts"]; subprocess.run(command, capture_output=True, text=True, check=True); UI.success("'edge-tts' åº“å·²æˆåŠŸæ›´æ–°ï¼")
    except Exception as e: UI.error(f"è‡ªåŠ¨æ›´æ–°æ—¶å‘ç”Ÿé”™è¯¯: {e}")
    UI.header("é‡è¦ï¼šè¯·é‡å¯å†…æ ¸ (å¿«æ·é”®: Ctrl + .) ç„¶åæŒ‰ F5 é‡æ–°è¿è¡Œç¨‹åºã€‚")
    pygame.quit(); sys.exit(0)
def run_async_task_in_thread(coro):
    exception = None
    def target():
        nonlocal exception
        try: loop = asyncio.new_event_loop(); asyncio.set_event_loop(loop); loop.run_until_complete(coro); loop.close()
        except Exception as e: exception = e
    thread = threading.Thread(target=target); thread.start(); thread.join()
    if exception: raise exception
async def generate_speech_edge(text, voice, filename, retries=3):
    for attempt in range(retries):
        try: communicate = edge_tts.Communicate(text, voice); await communicate.save(filename); return
        except edge_tts.exceptions.NoAudioReceived as e:
            if attempt < retries - 1: await asyncio.sleep(1)
            else: raise e

def speak_sentence(text_to_speak, voice_id):
    if not text_to_speak or not voice_id:
        UI.error("speak_sentence æ”¶åˆ°æ— æ•ˆå‚æ•° (æ–‡æœ¬æˆ–å£°éŸ³IDä¸ºç©º)ã€‚")
        return False
    cached_filepath = ""
    try:
        sentence_hash = hashlib.md5(text_to_speak.encode('utf-8')).hexdigest()
        safe_voice_id = voice_id.replace(":", "-").replace("|", "_")
        cache_prefix = "gtts" if '|' in voice_id else "edge" 
        cached_filename = f"{cache_prefix}_{sentence_hash}_{safe_voice_id}.mp3"
        cached_filepath = os.path.join(CACHE_DIR, cached_filename)
        
        generated_new_file = False
        if not os.path.exists(cached_filepath) or os.path.getsize(cached_filepath) == 0:
            UI.info(f"... æ­£åœ¨ä¸º '{text_to_speak}' ç”Ÿæˆè¯­éŸ³ ...")
            if cache_prefix == 'edge':
                speech_coroutine = generate_speech_edge(text_to_speak, voice_id, cached_filepath)
                run_async_task_in_thread(speech_coroutine)
            elif cache_prefix == 'gtts':
                try:
                    lang, tld = voice_id.split('|')
                    UI.info(f"(gTTS æ¨¡å¼: lang='{lang}', tld='{tld}')")
                    gtts_obj = gTTS(text=text_to_speak, lang=lang, tld=tld)
                    gtts_obj.save(cached_filepath)
                except Exception as gtts_error: UI.error(f"gTTS ç”ŸæˆéŸ³é¢‘æ—¶å¤±è´¥: {gtts_error}"); return False
            if not os.path.exists(cached_filepath) or os.path.getsize(cached_filepath) == 0: UI.error("ç”ŸæˆéŸ³é¢‘æ–‡ä»¶å¤±è´¥æˆ–æ–‡ä»¶ä¸ºç©ºã€‚"); return False
            generated_new_file = True
        
        pygame.mixer.music.load(cached_filepath); pygame.mixer.music.play(); UI.info(f"... ğŸ”Š æ­£åœ¨æœ—è¯»: '{text_to_speak}' ...")

        while pygame.mixer.music.get_busy(): time.sleep(0.1)
        pygame.mixer.music.unload()
        return 'GENERATED' if generated_new_file else 'CACHED'
    except (WSServerHandshakeError, edge_tts.exceptions.NoAudioReceived, Exception) as e:
        if cache_prefix == 'edge':
            error_str = str(e).lower()
            if "401" in error_str or "unauthorized" in error_str or ("status" in dir(e) and hasattr(e, 'status') and e.status == 401):
                raise UnauthorizedError(f"Original error: {e}") from e
        UI.error(f"å‘ç”Ÿç½‘ç»œæˆ–æ’­æ”¾é”™è¯¯: {e}")
        if isinstance(e, pygame.error) and cached_filepath and os.path.exists(cached_filepath): os.remove(cached_filepath)
        return False

def find_country_by_code(user_input, code_map):
    if not user_input: return None
    return code_map.get(user_input.upper())

def cleanup_on_exit():
    pygame.quit()
    UI.info("Pygame Mixer å·²è¢«å¸è½½ã€‚")
    if APP_MODE == 'original':
        if 'sentences' in globals() and sentences and 'current_index' in globals() and current_index < len(sentences):
            UI.info("ç¨‹åºå·²é€€å‡ºã€‚")
            unread_sentences = sentences[current_index:]
            with open(LEFTOVER_FILE, 'w', encoding='utf-8') as f:
                for sentence in unread_sentences: f.write(sentence + '\n')
            UI.info(f"å·²å°† {len(unread_sentences)} ä¸ªæœªè¯»å¥å­ä¿å­˜åˆ° '{LEFTOVER_FILE}'ã€‚")
        else:
            UI.success("æ‰€æœ‰å¥å­å·²å®Œæˆï¼Œç¨‹åºæ­£å¸¸ç»“æŸã€‚")
            for f in [STATE_FILE, LEFTOVER_FILE]:
                if os.path.exists(f): os.remove(f)
    
    elif APP_MODE == 'modified':
        if os.path.exists(MODIFIED_STATE_FILE):
            os.remove(MODIFIED_STATE_FILE)
        UI.info("ä¿®æ”¹æ¨¡å¼æ­£å¸¸é€€å‡ºã€‚")

    if os.path.exists(CACHE_DIR):
        try: shutil.rmtree(CACHE_DIR); UI.info(f"éŸ³é¢‘ç¼“å­˜ç›®å½• '{CACHE_DIR}' å·²æˆåŠŸåˆ é™¤ã€‚")
        except Exception as e: UI.error(f"æ¸…ç†ç¼“å­˜æ—¶å‘ç”Ÿé”™è¯¯: {e}")

    UI.info("ç¨‹åºå·²å®Œå…¨å…³é—­ã€‚"); UI.separator()

def check_and_highlight_spelling(original_sentence, user_spelling):
    translator = str.maketrans('', '', string.punctuation)
    original_words = [word.translate(translator).lower() for word in original_sentence.split()]
    user_words = [word.translate(translator).lower() for word in user_spelling.split()]
    matcher = difflib.SequenceMatcher(None, original_words, user_words)
    is_correct = True; highlighted_parts = []
    original_sentence_words = original_sentence.split()
    for tag, i1, i2, j1, j2 in matcher.get_opcodes():
        original_chunk = " ".join(original_sentence_words[i1:i2])
        if tag == 'equal': highlighted_parts.append(original_chunk)
        else:
            is_correct = False
            if original_chunk: highlighted_parts.append(f"{bcolors.RED}({original_chunk}){bcolors.ENDC}")
    highlighted_string = " ".join(highlighted_parts)
    return is_correct, highlighted_string

def save_spelling_error_sentence(sentence):
    error_file = MODIFIED_SPELLING_ERROR_FILE if APP_MODE == 'modified' else SPELLING_ERROR_FILE
    if not sentence: return
    try:
        existing_errors = []
        if os.path.exists(error_file):
            with open(error_file, 'r', encoding='utf-8') as f: existing_errors = [line.strip() for line in f]
        if sentence in existing_errors: UI.info(f"å¥å­ '{sentence[:30]}...' å·²å­˜åœ¨äºé”™è¯¯æ–‡ä»¶ä¸­ã€‚"); return
        with open(error_file, 'a', encoding='utf-8') as f: f.write(sentence + '\n')
        UI.info(f"å·²å°†é”™è¯¯å¥å­ '{sentence[:30]}...' è®°å½•åˆ° {os.path.basename(error_file)}")
    except Exception as e: UI.error(f"ä¿å­˜æ‹¼å†™é”™è¯¯æ—¶å‘ç”Ÿé”™è¯¯: {e}")

def get_existing_blind_spot_entries(filepath):
    if not os.path.exists(filepath): return set()
    try:
        workbook = openpyxl.load_workbook(filepath, read_only=True)
        sheet = workbook.active
        entries = set()
        for row in sheet.iter_rows(min_row=2, min_col=3, max_col=3, values_only=True):
            if row[0] is not None: entries.add(str(row[0]).strip())
        return entries
    except (PermissionError, Exception) as e:
        UI.error(f"æ£€æŸ¥é‡å¤å†…å®¹æ—¶æ— æ³•è¯»å– '{filepath}': {e}")
        return set()

def log_blind_spot_to_excel(sentence, voice_info, user_inputs):
    log_path = MODIFIED_BLIND_SPOT_LOG_PATH
    try:
        if not user_inputs:
            return False

        if os.path.exists(log_path):
            workbook = openpyxl.load_workbook(log_path)
            sheet = workbook.active
        else:
            workbook = openpyxl.Workbook()
            sheet = workbook.active
            sheet.append(["Sentence", "Voice Info", "User Input"])
        
        start_row = sheet.max_row + 1
        
        for i, user_input in enumerate(user_inputs):
            current_row = start_row + i
            sheet.cell(row=current_row, column=1, value=sentence)
            sheet.cell(row=current_row, column=2, value=voice_info)
            sheet.cell(row=current_row, column=3, value=user_input)
            
        workbook.save(log_path)
        UI.success(f"å·²æˆåŠŸå°† {len(user_inputs)} æ¡æ–°æ‰«ç›²è®°å½•ä¿å­˜åˆ° '{os.path.basename(log_path)}'ã€‚")
        return True
    except PermissionError:
        UI.error(f"ä¿å­˜å¤±è´¥ï¼è¯·å…ˆå…³é—­æ­£åœ¨æ‰“å¼€çš„Excelæ–‡ä»¶ '{log_path}'ã€‚")
        return False
    except Exception as e:
        UI.error(f"å†™å…¥æ‰«ç›²æ—¥å¿—æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
        return False

def print_available_voices(code_map):
    UI.separator()
    if TTS_ENGINE == 'edge':
        print(f"ğŸ¤ {bcolors.CYAN}Edge-TTS å¯ç”¨å›½å®¶/åœ°åŒºåŠå…¶ä»£ç ï¼š{bcolors.ENDC}")
        available_countries = sorted(voices_by_country.keys())
        if not available_countries: UI.info("æ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„å›½å®¶ã€‚"); UI.separator(); return
        max_len = max(len(c) for c in available_countries)
        num_columns = 2
        while len(available_countries) % num_columns != 0: available_countries.append("")
        num_rows = len(available_countries) // num_columns
        for i in range(num_rows):
            row_items = []
            for j in range(num_columns):
                country = available_countries[i + j * num_rows]
                if country:
                    codes = [k for k, v in code_map.items() if v == country]
                    code_str = "/".join(codes)
                    row_items.append(f"{bcolors.GREEN}{code_str:<5}{bcolors.ENDC} - {country:<{max_len}}")
            print(" | ".join(row_items))
    elif TTS_ENGINE == 'gtts':
        print(f"ğŸ¤ {bcolors.CYAN}gTTS å¯ç”¨å£éŸ³åˆ—è¡¨ï¼š{bcolors.ENDC}")
        for country, details in GTTS_VOICES.items():
            codes = [k for k, v in code_map.items() if v == country]
            code_str = "/".join(codes) if codes else "N/A"
            print(f"{bcolors.GREEN}{code_str:<5}{bcolors.ENDC} - {country:<18} ({details['desc']})")
    UI.separator()

def create_voice_map_dynamically(code_map, fallback_voices):
    UI.info("ğŸŒ æ­£åœ¨åŠ¨æ€è·å–æœ€æ–°çš„ Edge-TTS è¯­éŸ³åˆ—è¡¨...")
    UI.separator()
    voices_by_country_dynamic = {}
    async def fetch_and_build():
        voices = await edge_tts.list_voices()
        for voice in voices:
            locale = voice.get('Locale', '')
            parts = locale.split('-')
            if len(parts) >= 2:
                country_code = parts[1]
                country_name = code_map.get(country_code.upper())
                if country_name:
                    if country_name not in voices_by_country_dynamic: voices_by_country_dynamic[country_name] = []
                    voices_by_country_dynamic[country_name].append(voice['Name'])
    try: run_async_task_in_thread(fetch_and_build())
    except Exception as e: UI.error(f"åŠ¨æ€è·å–è¯­éŸ³åˆ—è¡¨æ—¶å‘ç”Ÿé”™è¯¯: {e}"); UI.info("å°†ä½¿ç”¨å†…ç½®çš„å¤‡ç”¨è¯­éŸ³åˆ—è¡¨ã€‚"); return fallback_voices
    if not voices_by_country_dynamic: UI.error("æœªèƒ½åŠ¨æ€è·å–åˆ°ä»»ä½•è¯­éŸ³ï¼Œå°†ä½¿ç”¨å†…ç½®çš„å¤‡ç”¨è¯­éŸ³åˆ—è¡¨ã€‚"); return fallback_voices
    UI.success("æˆåŠŸæ„å»ºäº†æœ€æ–°çš„ Edge-TTS è¯­éŸ³åº“ï¼"); print_available_voices(code_map); return voices_by_country_dynamic

def parse_excel_range(range_str, max_rows):
    range_str = range_str.upper().strip()
    if not range_str:
        return 2, max_rows
    
    match = re.match(r'^C(\d+):C(\d+)$', range_str)
    if not match:
        UI.error("èŒƒå›´æ ¼å¼æ— æ•ˆã€‚è¯·è¾“å…¥ç±»ä¼¼ 'C1:C100' çš„æ ¼å¼ã€‚")
        return None, None
    
    start = int(match.group(1))
    end = int(match.group(2))
    
    if start < 1 or end < start:
        UI.error("èŒƒå›´æ— æ•ˆã€‚èµ·å§‹è¡Œå¿…é¡»å°äºç­‰äºç»“æŸè¡Œï¼Œä¸”å¤§äº0ã€‚")
        return None, None
        
    return start, end

def find_exact_word_sequence(search_phrase_str, source_sentences):
    translator = str.maketrans('', '', string.punctuation)
    search_words = search_phrase_str.lower().translate(translator).split()
    if not search_words:
        return None

    for sentence in source_sentences:
        source_words = sentence.lower().translate(translator).split()
        
        len_search = len(search_words)
        for i in range(len(source_words) - len_search + 1):
            if source_words[i : i + len_search] == search_words:
                return sentence
    return None

def run_sentence_replacement_logic():
    UI.header("æ•°æ®é¢„å¤„ç† (ä¿®æ”¹æ¨¡å¼)")
    UI.info(f"æºå¥å­æ–‡ä»¶: {SPEECH_EXCEL_PATH}")
    UI.info(f"ç›®æ ‡æ‰«ç›²æ—¥å¿—: {MODIFIED_BLIND_SPOT_LOG_PATH}")
    try:
        df_sentences = pd.read_excel(SPEECH_EXCEL_PATH, header=None)
        source_sentences = [str(s).strip() for s in df_sentences.iloc[:, 0].tolist() if pd.notna(s) and str(s).strip()]
        if not source_sentences: UI.error("æºå¥å­æ–‡ä»¶ä¸ºç©ºæˆ–æ— æ³•è¯»å–ã€‚"); return False
        UI.info(f"æˆåŠŸè¯»å– {len(source_sentences)} ä¸ªæºå¥å­ã€‚")
        
        if not os.path.exists(MODIFIED_BLIND_SPOT_LOG_PATH): UI.error(f"ç›®æ ‡æ‰«ç›²æ—¥å¿—æ–‡ä»¶ '{MODIFIED_BLIND_SPOT_LOG_PATH}' ä¸å­˜åœ¨ã€‚"); return False
        workbook = openpyxl.load_workbook(MODIFIED_BLIND_SPOT_LOG_PATH)
        sheet = workbook.active

        start_row, end_row = None, None
        while start_row is None:
            range_input = UI.prompt(f"è¯·è¾“å…¥è¦åŒ¹é…çš„Cåˆ—èŒƒå›´ (ä¾‹å¦‚ C2:C100)ï¼Œæˆ–ç›´æ¥å›è½¦åŒ¹é…æ‰€æœ‰è¡Œ (1-{sheet.max_row}):")
            start_row, end_row = parse_excel_range(range_input, sheet.max_row)
            if start_row is None:
                continue
            end_row = min(end_row, sheet.max_row)

        UI.info(f"å°†åœ¨è¡Œ {start_row} åˆ° {end_row} çš„èŒƒå›´å†…è¿›è¡ŒåŒ¹é…...")
        
        replacements_count = 0
        for row_index in range(start_row, end_row + 1):
            sheet.cell(row=row_index, column=1, value=None)
            user_input = sheet.cell(row=row_index, column=3).value
            if not user_input or not isinstance(user_input, str): continue
            user_input = user_input.strip()
            
            best_sentence = find_exact_word_sequence(user_input, source_sentences)

            if best_sentence:
                original_sentence = sheet.cell(row=row_index, column=1).value
                if original_sentence != best_sentence:
                    sheet.cell(row=row_index, column=1, value=best_sentence)
                    replacements_count += 1
            else:
                UI.info(f"å¯¹äºæ‰«ç›²è¯ '{user_input}', åœ¨æºæ–‡ä»¶ä¸­æœªæ‰¾åˆ°å®Œå…¨åŒ¹é…çš„å¥å­ã€‚")

        if replacements_count > 0: UI.success(f"åœ¨æŒ‡å®šèŒƒå›´å†…æ‰¾åˆ°å¹¶æ›´æ–°äº† {replacements_count} ä¸ªå¥å­ã€‚")
        else: UI.info("åœ¨æŒ‡å®šèŒƒå›´å†…æ‰€æœ‰å¥å­å‡å·²æ˜¯æœ€æ–°ï¼Œæ— éœ€æ›´æ–°ã€‚")
        
        workbook.save(MODIFIED_BLIND_SPOT_LOG_PATH)
        UI.success(f"å·²æˆåŠŸä¿å­˜æ›´æ–°åçš„æ‰«ç›²æ—¥å¿— '{MODIFIED_BLIND_SPOT_LOG_PATH}'ã€‚")
        UI.separator()
        return True
    except FileNotFoundError as e: UI.error(f"æ–‡ä»¶æœªæ‰¾åˆ°: {e}"); return False
    except PermissionError: UI.error(f"ä¿å­˜å¤±è´¥ï¼è¯·å…ˆå…³é—­æ­£åœ¨æ‰“å¼€çš„Excelæ–‡ä»¶ '{MODIFIED_BLIND_SPOT_LOG_PATH}'ã€‚"); return False
    except Exception as e: UI.error(f"å¤„ç†Excelæ–‡ä»¶æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}"); return False

# ==============================================================================
# ç¬¬2éƒ¨åˆ†ï¼šåœ¨çº¿è¯å…¸åº”ç”¨
# ==============================================================================
DICT_EXCEL_PATH = "C:/Users/Administrator/Desktop/è‹±å›½è€é¼ /ç†Ÿè¯.xlsx"; DICT_SHEET_NAME = "Sheet1"; WORD_CACHE_FILE = "word_cache.txt"
MW_API_KEYS = ["aac6ea0e-417c-4eaf-ac85-0dc8f8a6ba13","93b2ec9c-d00c-4517-810a-ad2f8853fdfc"]; current_mw_api_key_index = 0
def get_current_mw_api_key(): global current_mw_api_key_index; return MW_API_KEYS[current_mw_api_key_index] if MW_API_KEYS else None
def switch_to_next_mw_api_key():
    global current_mw_api_key_index
    if len(MW_API_KEYS) <= 1: return
    previous_index = current_mw_api_key_index; current_mw_api_key_index = (current_mw_api_key_index + 1) % len(MW_API_KEYS)
    UI.info(f"ğŸ”„ API Key åˆ‡æ¢: ...{MW_API_KEYS[previous_index][-6:]} -> ...{get_current_mw_api_key()[-6:]}")
def print_mw_rate_limit_info(headers):
    limit = headers.get('X-RateLimit-Limit'); remaining = headers.get('X-RateLimit-Remaining')
    if limit and remaining: UI.info(f"ğŸ“Š éŸ¦æ°è¯å…¸API: å‰©ä½™ {remaining}/{limit}"); sys.stdout.flush();
    if remaining and int(remaining) <= 1: switch_to_next_mw_api_key()

def lookup_word_in_local_excel(word_to_find):
    UI.header("æœ¬åœ°è¯å…¸æŸ¥è¯¢")
    try:
        workbook = openpyxl.load_workbook(LOCAL_DICT_DATA_PATH, read_only=True, data_only=True)
        sheet = workbook['Sheet1']
        
        found = False
        for row in sheet.iter_rows(min_row=2): 
            word_cell_val = row[4].value # Column E (index 4)
            
            if word_cell_val and str(word_cell_val).strip().lower() == word_to_find.lower():
                etymology = row[8].value      # Column I
                definition = row[5].value     # Column F
                encounter_count = row[6].value# Column G
                memory_count = row[7].value   # Column H
                
                UI.info(f"å•è¯: {bcolors.GREEN}{word_cell_val}{bcolors.ENDC}")
                UI.info(f"é‡Šä¹‰: {definition if definition else 'N/A'}")
                UI.info(f"è¯æº: {etymology if etymology else 'N/A'}")
                UI.info(f"é‡è§æ¬¡æ•°: {encounter_count if encounter_count else 'N/A'}")
                UI.info(f"è®°å¿†æ¬¡æ•°: {memory_count if memory_count else 'N/A'}")
                found = True
                break
        
        if not found:
            UI.info(f"åœ¨æœ¬åœ°è¯å…¸ '{os.path.basename(LOCAL_DICT_DATA_PATH)}' ä¸­æœªæ‰¾åˆ° '{word_to_find}'ã€‚")

    except FileNotFoundError:
        UI.error(f"æœ¬åœ°è¯å…¸æ–‡ä»¶æœªæ‰¾åˆ°: {LOCAL_DICT_DATA_PATH}")
    except PermissionError:
        UI.error(f"æ— æ³•è¯»å–æœ¬åœ°è¯å…¸ï¼è¯·å…ˆå…³é—­æ­£åœ¨æ‰“å¼€çš„Excelæ–‡ä»¶ '{os.path.basename(LOCAL_DICT_DATA_PATH)}'ã€‚")
    except KeyError:
        UI.error(f"åœ¨Excelæ–‡ä»¶ '{os.path.basename(LOCAL_DICT_DATA_PATH)}' ä¸­æ‰¾ä¸åˆ°åä¸º 'Sheet1' çš„å·¥ä½œè¡¨ã€‚")
    except Exception as e:
        UI.error(f"è¯»å–æœ¬åœ°è¯å…¸æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
    finally:
        UI.separator()

def get_word_definition_merriam(word):
    if not word or not any(c.isalpha() for c in word):
        UI.error(f"æ— æ•ˆçš„æŸ¥è¯¢è¾“å…¥: '{word}'")
        return False

    api_key = get_current_mw_api_key()
    if not api_key:
        UI.error("éŸ¦æ°è¯å…¸API Keyåˆ—è¡¨ä¸ºç©ºã€‚")
        return False
    
    url = f"https://www.dictionaryapi.com/api/v3/references/collegiate/json/{word}?key={api_key}"
    UI.header("éŸ¦æ°è¯å…¸ (åœ¨çº¿)")
    print(f"ğŸ“š {bcolors.CYAN}æ­£åœ¨æŸ¥è¯¢: {word}{bcolors.ENDC}")

    for attempt in range(3):
        try:
            response = requests.get(url, timeout=10)
            print_mw_rate_limit_info(response.headers)
            
            if response.status_code in [200, 404]:
                break
            
            response.raise_for_status()

        except requests.exceptions.RequestException as e:
            UI.error(f"ç½‘ç»œè¿æ¥é”™è¯¯: {e} (å°è¯• {attempt + 1}/3)")
            if attempt < 2:
                UI.info("å°†åœ¨1ç§’åé‡è¯•..."); time.sleep(1)
            else:
                UI.error("æŸ¥è¯¢å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ã€‚")
                return False
    
    try:
        data = response.json()
        if not data or not isinstance(data[0], dict):
            suggestions = data if isinstance(data, list) and all(isinstance(i, str) for i in data) else []
            UI.error(f"åœ¨çº¿è¯å…¸ä¸­æ²¡æœ‰æ‰¾åˆ°å•è¯ '{word}'ã€‚")
            if suggestions: UI.info(f"æ‹¼å†™å»ºè®®: {', '.join(suggestions)}")
            return False

        found_definition = False
        print(f"å•è¯: {bcolors.GREEN}{word.capitalize()}{bcolors.ENDC}")
        for entry in data:
            if isinstance(entry, dict) and entry.get('meta', {}).get('id', '').split(':')[0].lower() == word.lower():
                if 'fl' in entry: print(f"\nã€{bcolors.CYAN}{entry['fl']}{bcolors.ENDC}ã€‘")
                if 'shortdef' in entry:
                    for i, definition in enumerate(entry['shortdef']):
                        print(f"  {i+1}. {definition.replace('{bc}', '').replace('{it}', '').replace('{/it}', '')}")
                    found_definition = True
        return found_definition
    except Exception as e:
        UI.error(f"è§£æåœ¨çº¿è¯å…¸æ•°æ®æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}")
        return False

def save_word_to_cache(word, cache_filepath):
    try:
        with open(cache_filepath, 'a', encoding='utf-8') as f: f.write(word + '\n')
        UI.success(f"å•è¯ '{word}' å·²ç¼“å­˜ï¼Œå°†åœ¨ä¸‹æ¬¡å¯åŠ¨æ—¶ä¿å­˜ã€‚")
    except Exception as e: UI.error(f"ç¼“å­˜å•è¯æ—¶å‘ç”Ÿé”™è¯¯: {e}")
def _write_words_to_excel_core(words, filepath, sheetname):
    if not words: return True
    try:
        directory = os.path.dirname(filepath)
        if directory and not os.path.exists(directory): os.makedirs(directory)
        workbook = openpyxl.load_workbook(filepath) if os.path.exists(filepath) else openpyxl.Workbook()
        sheet = workbook[sheetname] if sheetname in workbook.sheetnames else workbook.create_sheet(sheetname)
        target_row = 1
        while sheet.cell(row=target_row, column=1).value is not None: target_row += 1
        for word in words: sheet.cell(row=target_row, column=1, value=word); target_row += 1
        workbook.save(filepath); UI.success(f"æˆåŠŸï¼{len(words)} ä¸ªç¼“å­˜çš„å•è¯å·²ä¿å­˜åˆ°Excelã€‚"); return True
    except PermissionError: UI.error(f"æ— æ³•å†™å…¥Excelï¼è¯·å…ˆå…³é—­æ­£åœ¨æ‰“å¼€çš„æ–‡ä»¶ '{filepath}'ã€‚"); return False
    except Exception as e: UI.error(f"å†™å…¥Excelæ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯: {e}"); return False
def get_word_definition(word):
    UI.header("DictionaryAPI (åœ¨çº¿)")
    print(f"ğŸ“š {bcolors.CYAN}æ­£åœ¨æŸ¥è¯¢å•è¯: {word}{bcolors.ENDC}"); url = f"https://api.dictionaryapi.dev/api/v2/entries/en/{word}"
    for attempt in range(3):
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                data = response.json()[0]; print(f"å•è¯: {bcolors.GREEN}{data['word']}{bcolors.ENDC}")
                for meaning in data['meanings']:
                    print(f"\nã€{bcolors.CYAN}{meaning['partOfSpeech']}{bcolors.ENDC}ã€‘")
                    for i, definition in enumerate(meaning['definitions']): print(f"{i+1}. {definition['definition']}")
                return True
            elif response.status_code == 404: UI.error(f"æŠ±æ­‰ï¼Œåœ¨çº¿è¯å…¸ä¸­æ²¡æœ‰æ‰¾åˆ°å•è¯ '{word}'ã€‚"); return False
            else: UI.error(f"æŸ¥è¯¢å‡ºé”™ï¼ŒçŠ¶æ€ç : {response.status_code} (å°è¯• {attempt + 1}/3)")
        except requests.exceptions.RequestException as e: UI.error(f"ç½‘ç»œè¿æ¥é”™è¯¯: {e} (å°è¯• {attempt + 1}/3)")
        if attempt < 2: UI.info("å°†åœ¨1ç§’åé‡è¯•..."); time.sleep(1)
    UI.error("æŸ¥è¯¢å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ã€‚"); return False

# ==============================================================================
# ç¬¬3éƒ¨åˆ†ï¼šåº”ç”¨åˆ‡æ¢é€»è¾‘
# ==============================================================================
speech_app_initialized = False; sentences = []; current_index = 0
default_country = "United States"; last_used_voice = None; word_to_lookup_on_switch = None

def initialize_speech_app():
    global sentences, current_index, speech_app_initialized
    if speech_app_initialized: return True
    UI.info("æ­£åœ¨åˆå§‹åŒ–è¯­éŸ³æœ—è¯»ç¨‹åº...")
    load_from_excel = True
    if os.path.exists(LEFTOVER_FILE) and os.path.getsize(LEFTOVER_FILE) > 0:
        with open(LEFTOVER_FILE, 'r', encoding='utf-8') as f: leftover = [line.strip() for line in f if line.strip()]
        if leftover:
            UI.separator(); choice = UI.prompt(f"æ£€æµ‹åˆ°ä¸Šæ¬¡æœ‰ {len(leftover)} å¥æœªè¯»ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ(Y/n): ").strip().lower()
            if choice in ['y', 'yes', '']: sentences = leftover; load_from_excel = False
    if load_from_excel:
        try:
            df = pd.read_excel(SPEECH_EXCEL_PATH, header=None); raw = df.iloc[:, 0].tolist()
            sentences = [str(s).strip().replace('\n', ' ') for s in raw if pd.notna(s) and str(s).strip()]
            if not sentences: UI.error(f"Excelæ–‡ä»¶ '{SPEECH_EXCEL_PATH}' ä¸ºç©ºã€‚"); UI.separator(); return False
            UI.success(f"æˆåŠŸä»Excelè¯»å– {len(sentences)} ä¸ªå¥å­å¹¶æ‰“ä¹±é¡ºåºã€‚"); random.shuffle(sentences)
        except FileNotFoundError: UI.error(f"æ–‡ä»¶æœªæ‰¾åˆ° '{SPEECH_EXCEL_PATH}'ã€‚"); UI.separator(); return False
        except Exception as e: UI.error(f"è¯»å–Excelæ—¶å‘ç”Ÿé”™è¯¯: {e}ã€‚"); UI.separator(); return False
    start_index = 0
    if os.path.exists(STATE_FILE):
        try:
            with open(STATE_FILE, 'r') as f: content = f.read().strip()
            if content:
                saved_index_str, saved_hash = content.split('|')
                current_hash = hashlib.md5("".join(sentences).encode('utf-8')).hexdigest()
                if current_hash == saved_hash: start_index = int(saved_index_str)
        except Exception: pass
    current_index = start_index
    UI.info(f"è¯­éŸ³æœ—è¯»å‡†å¤‡å°±ç»ªï¼Œå°†ä»ç¬¬ {current_index + 1} å¥å¼€å§‹ã€‚")
    speech_app_initialized = True; return True

def handle_spelling_session(sentence, voice):
    typed_so_far = ""
    while True:
        print(f"\nâœï¸  å½“å‰å·²è¾“å…¥: {bcolors.CYAN}{typed_so_far}{bcolors.ENDC}"); prompt_text = "è¾“å…¥ '.' æäº¤, Enter é‡å¬, æˆ–ç»§ç»­è¾“å…¥: "
        try: user_action = UI.prompt(prompt_text)
        except (KeyboardInterrupt, EOFError): print("\n"); UI.error("æ‹¼å†™å·²å–æ¶ˆã€‚"); return None
        if user_action == "": UI.info("...é‡å¬éŸ³é¢‘..."); speak_sentence(sentence, voice); UI.separator(); continue
        if user_action == ".": return typed_so_far
        typed_so_far = typed_so_far + " " + user_action if typed_so_far else user_action

def handle_blind_spot_logging(sentence, voice_info_str):
    blind_spot_input = UI.prompt("è¯·è¾“å…¥æ‚¨ä¸ç†Ÿæ‚‰çš„å•è¯æˆ–è¯ç»„ï¼Œç”¨è‹±æ–‡é€—å·éš”é–‹: ").strip()
    if not blind_spot_input: return
    
    user_items = [item.strip() for item in blind_spot_input.split(',') if item.strip()]
    existing_entries = get_existing_blind_spot_entries(MODIFIED_BLIND_SPOT_LOG_PATH)
    
    valid_items_to_log, invalid_items, duplicate_items = [], [], []
    translator = str.maketrans('', '', string.punctuation)
    clean_sentence_words = [word.translate(translator).lower() for word in sentence.split()]
    
    for item in user_items:
        clean_item_words = [word.translate(translator).lower() for word in item.split() if word]
        if not clean_item_words: continue
        
        is_valid_phrase = False
        item_len = len(clean_item_words)
        for i in range(len(clean_sentence_words) - item_len + 1):
            if clean_sentence_words[i:i + item_len] == clean_item_words:
                is_valid_phrase = True
                break
        
        if is_valid_phrase:
            if item in existing_entries: duplicate_items.append(item)
            else: valid_items_to_log.append(item)
        else: invalid_items.append(item)
    
    if valid_items_to_log:
        log_blind_spot_to_excel(sentence, voice_info_str, valid_items_to_log)

    elif not invalid_items and not duplicate_items: 
        UI.info("æ²¡æœ‰éœ€è¦è®°å½•çš„æ–°å†…å®¹ã€‚")

    if duplicate_items: UI.info(f"å·²æœ‰é‡å¤å†…å®¹ï¼Œå·²å¿½ç•¥: {', '.join(duplicate_items)}")
    if invalid_items: UI.error(f"è¾“å…¥å†…å®¹æœ‰è¯¯æˆ–æœªåœ¨å¥å­ä¸­æ‰¾åˆ°ï¼Œå·²å¿½ç•¥: {', '.join(invalid_items)}")
    UI.separator()

def handle_speech_interaction():
    global current_index, default_country, last_used_voice, sentences
    
    current_sentence = sentences[current_index]
    print(f"ğŸ¤ {bcolors.CYAN}--- è¯­éŸ³æœ—è¯» ({current_index + 1}/{len(sentences)}) ---{bcolors.ENDC}")
    print(f"   å¥å­: '{current_sentence}'")
    
    played_successfully = False
    
    if TTS_ENGINE == 'gtts':
        country_info = GTTS_VOICES.get(default_country)
        if not country_info: UI.error(f"gTTS ä¸æ”¯æŒå›½å®¶ '{default_country}'ã€‚è¯·åˆ‡æ¢å›½å®¶ã€‚"); last_used_voice = None
        else:
            voice_to_use = f"{country_info['lang']}|{country_info['tld']}"
            if last_used_voice and last_used_voice != voice_to_use: UI.info(f"å›½å®¶å·²å˜æ›´ï¼Œåˆ‡æ¢ gTTS å£°éŸ³...")
            last_used_voice = voice_to_use
            if speak_sentence(current_sentence, last_used_voice): played_successfully = True
    else:
        if last_used_voice is None:
            tried_voices_this_sentence = set()
            voice_scores = load_voice_scores()
            country_voices = voices_by_country.get(default_country, [])
            candidate_voices = [v for v in country_voices if v != last_used_voice]
            first_try_voice = random.choice(candidate_voices) if candidate_voices else (country_voices[0] if country_voices else None)
            if first_try_voice:
                tried_voices_this_sentence.add(first_try_voice)
                try:
                    UI.info(f"é¦–æ¬¡å°è¯• (éšæœºé€‰æ‹©ï¼Œæƒé‡: {voice_scores.get(first_try_voice, 0)}): {first_try_voice}")
                    result = speak_sentence(current_sentence, first_try_voice)
                    if result:
                        if result == 'GENERATED': update_voice_score(first_try_voice, 1)
                        last_used_voice = first_try_voice; played_successfully = True
                except UnauthorizedError:
                    UI.error(f"é¦–æ¬¡å°è¯•çš„å£°éŸ³ '{first_try_voice}' æˆæƒå¤±è´¥ã€‚å°†å¯åŠ¨å¥å£®æ¨¡å¼..."); update_voice_score(first_try_voice, -1)
            if not played_successfully:
                def attempt_playback_robust(country, limit, is_fallback=False):
                    nonlocal played_successfully; global last_used_voice
                    stage_name = "åå¤‡" if is_fallback else "ä¸»"; UI.info(f"{stage_name}é‡è¯• (åŸºäºæƒé‡): {country} (æœ€å¤š {limit} æ¬¡)...")
                    for attempt in range(limit):
                        voices_to_try = voices_by_country.get(country, [])
                        prioritized_list = get_prioritized_voices(voices_to_try, voice_scores, tried_voices_this_sentence)
                        if not prioritized_list: UI.error(f"{stage_name}å›½å®¶æ‰€æœ‰å¯ç”¨å£°éŸ³å‡å·²å°è¯•ã€‚"); return
                        current_voice = prioritized_list[0]; tried_voices_this_sentence.add(current_voice)
                        try:
                            UI.info(f"å°è¯•{stage_name}å£°éŸ³ (æƒé‡: {voice_scores.get(current_voice, 0)}): {current_voice} ({attempt + 1}/{limit})")
                            result = speak_sentence(current_sentence, current_voice)
                            if result:
                                if result == 'GENERATED': update_voice_score(current_voice, 1)
                                last_used_voice = current_voice; played_successfully = True; return
                        except UnauthorizedError: UI.error(f"å£°éŸ³ '{current_voice}' æˆæƒå¤±è´¥ã€‚"); update_voice_score(current_voice, -1); time.sleep(0.5)
                attempt_playback_robust(default_country, PRIMARY_RETRY_LIMIT)
                if not played_successfully: attempt_playback_robust(FALLBACK_COUNTRY, FALLBACK_RETRY_LIMIT, is_fallback=True)
        else:
            UI.info(f"é‡å¤æ’­æ”¾ (ä½¿ç”¨ç¼“å­˜å£°éŸ³ï¼Œæƒé‡: {load_voice_scores().get(last_used_voice, 0)}): {last_used_voice}")
            result = speak_sentence(current_sentence, last_used_voice)
            if result: played_successfully = True
            else: UI.error(f"ç¼“å­˜æ–‡ä»¶æ’­æ”¾å¤±è´¥ï¼Œå°†å°è¯•é‡æ–°é€‰æ‹©å£°éŸ³ã€‚"); last_used_voice = None

    if not played_successfully:
        UI.error("æ’­æ”¾å¤±è´¥ï¼Œæ— æ³•ç»§ç»­ã€‚")
        if last_used_voice is None and TTS_ENGINE == 'edge': handle_auth_error_and_exit()
        UI.separator(); return 'CONTINUE'

    voice_info_str = "Unknown"
    if last_used_voice:
        if TTS_ENGINE == 'edge': voice_info_str = f"Edge-TTS: {default_country}, {last_used_voice}"
        elif TTS_ENGINE == 'gtts':
            try:
                lang, tld = last_used_voice.split('|')
                country_name = "Unknown Country"; desc = ""
                for country, details in GTTS_VOICES.items():
                    if details['lang'] == lang and details['tld'] == tld: country_name, desc = country, details.get('desc', ''); break
                voice_info_str = f"gTTS: {country_name} ({desc})"
            except: voice_info_str = f"gTTS: {last_used_voice}"

    # Inner loop for non-moving commands
    while True:
        UI.separator()
        prompt_text = "æŒ‡ä»¤: (e)æ‰«ç›², (s)å¥å­, (w)å•è¯, (.)ä¸‹ä¸€å¥, (l)ä¸Šä¸€å¥, (v)çœ‹è¯­éŸ³åº“, (z)æ¢äºº, (Enter)é‡å¬, (q)é€€å‡º: "
        user_input = UI.prompt(prompt_text).strip(); lower_input = user_input.lower()
        
        # Break for commands that move to the next/prev item or exit
        if lower_input in ['.', 'ã€‚', 'n', 'l', 'q', 'm', '2'] or (user_input and not lower_input in ['e','s','w','z','v',''] and not find_country_by_code(user_input, country_code_map)):
             break

        if lower_input == 'e':
            handle_blind_spot_logging(current_sentence, voice_info_str)
        elif lower_input == 's':
            user_spelling = handle_spelling_session(current_sentence, last_used_voice)
            if user_spelling is not None:
                is_correct, highlighted_string = check_and_highlight_spelling(current_sentence, user_spelling)
                print(f"âœï¸  {bcolors.CYAN}--- æ‹¼å†™æ£€æŸ¥ç»“æœ ---{bcolors.ENDC}"); print(f"   ç»“æœ: {highlighted_string}")
                if is_correct: UI.success("å¥å­æ‹¼å†™å®Œå…¨æ­£ç¡®ï¼")
                else: UI.error("å¥å­æ‹¼å†™æœ‰è¯¯ã€‚"); save_spelling_error_sentence(current_sentence)
        elif lower_input == 'w':
            user_words_input = handle_spelling_session(current_sentence, last_used_voice)
            if user_words_input is not None:
                translator = str.maketrans('', '', string.punctuation); clean_original_words = {word.translate(translator).lower() for word in current_sentence.split()}; user_words = user_words_input.split(); all_found = True; not_found_words = []
                for word in user_words:
                    if word.strip() and word.translate(translator).lower() not in clean_original_words: all_found = False; not_found_words.append(word)
                if all_found: UI.success(f"å•è¯/è¯ç»„ '{user_words_input}' å‡å­˜åœ¨äºå¥å­ä¸­ï¼Œæ‹¼å†™æ­£ç¡®ï¼")
                else: UI.error(f"å•è¯ '{', '.join(not_found_words)}' ä¸åœ¨å¥å­ä¸­æˆ–æ‹¼å†™é”™è¯¯ã€‚"); save_spelling_error_sentence(current_sentence)
        elif user_input == '':
            speak_sentence(current_sentence, last_used_voice)
        elif lower_input == 'z':
            if TTS_ENGINE == 'gtts': UI.info("gTTSæ¨¡å¼ä¸‹æ— æ³•åˆ‡æ¢å•ä¸ªå£°éŸ³ï¼Œè¯·ä½¿ç”¨å›½å®¶ä»£ç åˆ‡æ¢å£éŸ³ã€‚")
            else:
                last_used_voice = None # Signal to pick a new voice
                speak_sentence(current_sentence, last_used_voice)
        elif lower_input == 'v':
            print_available_voices(country_code_map)
        else:
            matched_country = find_country_by_code(user_input, country_code_map)
            if matched_country:
                if TTS_ENGINE == 'gtts' and matched_country not in GTTS_VOICES:
                    UI.error(f"gTTS ä¸æ”¯æŒå›½å®¶ '{matched_country}'ã€‚è¯·ä» 'v' åˆ—è¡¨ä¸­é€‰æ‹©ã€‚")
                else:
                    default_country = matched_country
                    UI.info(f"å›½å®¶å·²åˆ‡æ¢åˆ°: {default_country}ã€‚")
                    if TTS_ENGINE == 'edge': last_used_voice = None
                    speak_sentence(current_sentence, last_used_voice) # Replay with new country voice

    # Handle commands that break the inner loop
    if lower_input in ['.', 'ã€‚', 'n']:
        current_index += 1
        last_used_voice = None
    elif lower_input == 'l':
        current_index = max(0, current_index - 1)
        last_used_voice = None
    elif lower_input == 'q': return 'QUIT'
    elif lower_input == 'm': return 'GOTO_MENU'
    elif lower_input == '2': return 'SWITCH_TO_2'
    else:
        return ('SWITCH_TO_2_WITH_WORD', user_input)
    
    return 'CONTINUE'

def prompt_for_error_rerun(target_mode):
    global sentences, current_index, speech_app_initialized
    global modified_playback_list, modified_current_index, modified_app_initialized

    error_file = MODIFIED_SPELLING_ERROR_FILE if target_mode == 'modified' else SPELLING_ERROR_FILE

    if not os.path.exists(error_file) or os.path.getsize(error_file) == 0:
        return False
    
    choice = UI.prompt(f"æ£€æµ‹åˆ° {os.path.basename(error_file)} ä¸­æœ‰å†…å®¹ï¼Œæ˜¯å¦å¼€å§‹å¤ä¹ ï¼Ÿ (Y/n): ").strip().lower()
    if choice in ['y', 'yes', '']:
        UI.info(f"æ­£åœ¨ä» {os.path.basename(error_file)} åŠ è½½å¤ä¹ å†…å®¹...")
        try:
            with open(error_file, 'r', encoding='utf-8') as f:
                error_content = list(dict.fromkeys([line.strip() for line in f if line.strip()]))
            if not error_content:
                os.remove(error_file)
                return False
            
            if target_mode == 'original':
                sentences = error_content
                current_index = 0
                speech_app_initialized = True
                random.shuffle(sentences)
                UI.success(f"åŠ è½½æˆåŠŸï¼å°†å¼€å§‹å¤ä¹  {len(sentences)} ä¸ªé”™è¯¯é¡¹ç›®ã€‚")
            elif target_mode == 'modified':
                df_log = pd.read_excel(MODIFIED_BLIND_SPOT_LOG_PATH)
                log_data = {str(row['Sentence']).strip(): (row['Voice Info'], row['User Input'], row.name + 2) for index, row in df_log.iterrows() if pd.notna(row['Sentence'])}
                
                review_list = []
                for sentence in error_content:
                    if sentence in log_data:
                        review_list.append([sentence] + list(log_data[sentence]))
                    else:
                        UI.info(f"é”™è¯¯å¥å­ '{sentence[:30]}...' åœ¨æ—¥å¿—ä¸­æœªæ‰¾åˆ°ï¼Œå·²è·³è¿‡ã€‚")
                
                if not review_list:
                    UI.error("æ— æ³•ä¸ºä»»ä½•é”™è¯¯å¥å­æ‰¾åˆ°å¯¹åº”çš„æ—¥å¿—ä¿¡æ¯ï¼Œæ— æ³•å¼€å§‹å¤ä¹ ã€‚")
                    os.remove(error_file)
                    return False
                
                modified_playback_list = review_list
                modified_current_index = 0
                modified_app_initialized = True
                UI.success(f"åŠ è½½æˆåŠŸï¼å°†å¼€å§‹å¤ä¹  {len(modified_playback_list)} ä¸ªé”™è¯¯é¡¹ç›®ã€‚")

            os.remove(error_file)
            UI.separator()
            return True
        except Exception as e:
            UI.error(f"ä»é”™è¯¯æ–‡ä»¶åŠ è½½æ—¶å‡ºé”™: {e}")
            if os.path.exists(error_file): os.remove(error_file)
            UI.separator()
            return False
    else:
        UI.info(f"å¥½çš„ï¼Œå°†æ¸…ç©ºå¹¶åˆ é™¤ {os.path.basename(error_file)}ã€‚")
        if os.path.exists(error_file): os.remove(error_file)
        UI.separator()
        return False

# ==============================================================================
# ç¬¬4éƒ¨åˆ†ï¼šä¸»æ§åˆ¶å™¨
# ==============================================================================
def process_word_cache_on_startup():
    if not os.path.exists(WORD_CACHE_FILE) or os.path.getsize(WORD_CACHE_FILE) == 0: return
    UI.info("æ­£åœ¨å¤„ç†å•è¯ç¼“å­˜..."); UI.separator()
    try:
        try: workbook = openpyxl.load_workbook(DICT_EXCEL_PATH); sheet = workbook[DICT_SHEET_NAME]; current_total = sheet.max_row
        except (FileNotFoundError, KeyError): current_total = 0
        with open(WORD_CACHE_FILE, 'r', encoding='utf-8') as f: words_to_save = list(dict.fromkeys([line.strip() for line in f if line.strip()]))
        if not words_to_save: os.remove(WORD_CACHE_FILE); UI.info(f"å½“å‰ç†Ÿè¯åº“ '{os.path.basename(DICT_EXCEL_PATH)}' ä¸­å…±æœ‰ {current_total} ä¸ªå•è¯ã€‚"); UI.separator(); return
        success = _write_words_to_excel_core(words_to_save, DICT_EXCEL_PATH, DICT_SHEET_NAME)
        if success:
            new_total = current_total + len(words_to_save); UI.info("å•è¯ç¼“å­˜å·²æ¸…ç©ºã€‚"); UI.success(f"å½“å‰ç†Ÿè¯åº“ '{os.path.basename(DICT_EXCEL_PATH)}' ä¸­å…±æœ‰ {new_total} ä¸ªå•è¯ã€‚"); os.remove(WORD_CACHE_FILE)
        else: UI.error("å†™å…¥Excelå¤±è´¥ã€‚ç¼“å­˜æ–‡ä»¶å·²ä¿ç•™ï¼Œä¸‹æ¬¡å¯åŠ¨å°†é‡è¯•ã€‚")
    except Exception as e: UI.error(f"å¤„ç†å•è¯ç¼“å­˜æ—¶å‘ç”Ÿä¸¥é‡é”™è¯¯: {e}"); UI.info("ç¼“å­˜æ–‡ä»¶å·²ä¿ç•™ï¼Œä¸‹æ¬¡å¯åŠ¨å°†é‡è¯•ã€‚")
    UI.separator()

def run_dictionary_loop(initial_word=None):
    # =================== FIX: Remove repetitive header ===================
    # UI.header("åœ¨çº¿è¯å…¸")
    # UI.info(f"æŸ¥åˆ°çš„å•è¯å°†æè®®ä¿å­˜åˆ°: {DICT_EXCEL_PATH}")
    # UI.info("å…¨å±€æŒ‡ä»¤: '1'è¯­éŸ³æœ—è¯» | 'm'ä¸»èœå• | 'q'é€€å‡º")
    # UI.separator()
    # =====================================================================
    
    word_to_save = None
    
    def perform_lookup(word):
        nonlocal word_to_save
        lookup_word_in_local_excel(word)
        found_online = get_word_definition_merriam(word) if DICTIONARY_CHOICE == '2' else get_word_definition(word)
        if found_online:
            word_to_save = word
        else:
            word_to_save = None # Clear if not found online
        UI.separator()
    
    if initial_word:
        perform_lookup(initial_word)

    while True:
        prompt_text = f"æ˜¯å¦ä¿å­˜å•è¯ '{word_to_save}'? (Enter=ä¿å­˜, æˆ–è¾“å…¥æ–°å•è¯/æŒ‡ä»¤): " if word_to_save else "è¯·è¾“å…¥å•è¯ (æˆ–å…¨å±€æŒ‡ä»¤): "
        user_input = UI.prompt(prompt_text).strip()
        
        if word_to_save and user_input == '':
            save_word_to_cache(word_to_save, WORD_CACHE_FILE)
            word_to_save = None
            continue
            
        lower_input = user_input.lower()
        if lower_input in ['1', 'm', 'q']:
            if word_to_save: UI.info(f"æ“ä½œå–æ¶ˆï¼Œæœªä¿å­˜å•è¯ '{word_to_save}'ã€‚")
            if lower_input == '1': return 'SWITCH_TO_1'
            if lower_input == 'm': return 'GOTO_MENU'
            if lower_input == 'q': return 'QUIT'
            
        if word_to_save: UI.info(f"æ“ä½œå–æ¶ˆï¼Œæœªä¿å­˜å•è¯ '{word_to_save}'ã€‚")
        word_to_save = None 
        
        if not user_input:
            continue
        
        perform_lookup(user_input)

def initialize_modified_app():
    global modified_playback_list, modified_current_index, modified_app_initialized
    if modified_app_initialized: return True
    
    UI.info("æ­£åœ¨åˆå§‹åŒ–ä¿®æ”¹æ¨¡å¼å¹¶è¿›è¡Œæ•°æ®åŒæ­¥...")
    try:
        df_sentences = pd.read_excel(SPEECH_EXCEL_PATH, header=None)
        source_sentences_set = {str(s).strip() for s in df_sentences.iloc[:, 0].tolist() if pd.notna(s) and str(s).strip()}
        if not source_sentences_set: 
            UI.error(f"ä¸»å¥å­æ–‡ä»¶ '{os.path.basename(SPEECH_EXCEL_PATH)}' ä¸ºç©ºã€‚")
            return False

        if not os.path.exists(MODIFIED_BLIND_SPOT_LOG_PATH):
            UI.error(f"æ‰«ç›²æ—¥å¿— '{os.path.basename(MODIFIED_BLIND_SPOT_LOG_PATH)}' ä¸å­˜åœ¨ã€‚")
            return False
        df_log = pd.read_excel(MODIFIED_BLIND_SPOT_LOG_PATH)

        matched_items = []
        unmatched_rows_to_delete = []
        for index, row in df_log.iterrows():
            log_sentence = str(row.get('Sentence', '')).strip()
            original_row_num = index + 2

            if log_sentence and log_sentence in source_sentences_set:
                item_data = (row.get('Voice Info'), row.get('User Input'), original_row_num)
                matched_items.append([log_sentence] + list(item_data))
            elif log_sentence:
                unmatched_rows_to_delete.append(original_row_num)
                UI.info(f"å‘ç°æœªåŒ¹é…è¡Œ (æ—¥å¿—ç¬¬ {original_row_num} è¡Œ): '{log_sentence[:30]}...' å°†è¢«æ¸…ç†ã€‚")
        
        if unmatched_rows_to_delete:
            if not delete_multiple_rows_from_excel(MODIFIED_BLIND_SPOT_LOG_PATH, unmatched_rows_to_delete):
                UI.error("æ¸…ç†æœªåŒ¹é…è¡Œå¤±è´¥ï¼Œæ— æ³•å®‰å…¨ç»§ç»­ã€‚")
                return False
        
        modified_playback_list = matched_items
        if not modified_playback_list:
            UI.error("æœªèƒ½æ„å»ºä»»ä½•å¯æœ—è¯»çš„é¡¹ç›® (æ‰«ç›²æ—¥å¿—ä¸­çš„å¥å­åœ¨ä¸»æ–‡ä»¶ä¸­å‡æœªæ‰¾åˆ°ï¼Œæˆ–æ—¥å¿—ä¸ºç©º)ã€‚")
            return False

        modified_current_index = 0
        modified_app_initialized = True
        UI.success(f"æ•°æ®åŒæ­¥å®Œæˆï¼ŒæˆåŠŸæ„å»º {len(modified_playback_list)} æ¡æœ—è¯»ä»»åŠ¡ã€‚")
        return True

    except FileNotFoundError as e:
        UI.error(f"æ–‡ä»¶æœªæ‰¾åˆ°: {e}")
        return False
    except Exception as e:
        UI.error(f"åˆå§‹åŒ–ä¿®æ”¹æ¨¡å¼æ—¶å‡ºé”™: {e}")
        return False

def run_modified_speech_app():
    global modified_current_index, word_to_lookup_on_switch, modified_app_initialized, modified_playback_list, default_country
    
    session_voice_override = None

    while modified_current_index < len(modified_playback_list):
        current_item = modified_playback_list[modified_current_index]
        sentence, voice_info, user_input_text, original_row = current_item
        
        active_voice_id = None
        try:
            if TTS_ENGINE == 'gtts':
                country_info = GTTS_VOICES.get(default_country)
                if not country_info:
                    UI.error(f"gTTS ä¸æ”¯æŒå½“å‰å›½å®¶ '{default_country}'ã€‚è¯·ä½¿ç”¨å›½å®¶ä»£ç åˆ‡æ¢ã€‚")
                    modified_current_index += 1
                    continue
                active_voice_id = f"{country_info['lang']}|{country_info['tld']}"
                UI.info(f"gTTS æ¨¡å¼å·²æ¿€æ´»ã€‚ä½¿ç”¨ '{default_country}' çš„å£°éŸ³ã€‚")
            else:
                default_voice_id = None
                match = re.search(r'([a-z]{2}-[A-Z]{2}-\w+Neural)', str(voice_info))
                if match:
                    default_voice_id = match.group(1)
                else:
                    match_old = re.search(r'\(([a-z]{2}-[A-Z]{2}),\s*(\w+Neural)\)', str(voice_info))
                    if match_old:
                        default_voice_id = f"{match_old.group(1)}-{match_old.group(2)}"
                    else:
                        raise ValueError("åœ¨Voice Infoä¸­æ‰¾ä¸åˆ°æœ‰æ•ˆçš„Edge-TTSè¯­éŸ³ID")
                if not default_voice_id: raise ValueError("æ— æ³•è§£æé»˜è®¤å£°éŸ³ID")
                
                active_voice_id = session_voice_override if session_voice_override else default_voice_id
                if session_voice_override is None:
                    UI.info(f"å·²åŠ è½½é»˜è®¤å£°éŸ³: {active_voice_id}")

        except Exception as e:
            UI.error(f"è§£æé»˜è®¤å£°éŸ³å¤±è´¥ ('{voice_info}'): {e}ã€‚å°†ä»åˆ—è¡¨ä¸­ç§»é™¤æ­¤æ¡ç›®ã€‚")
            modified_playback_list.pop(modified_current_index)
            continue
            
        print(f"ğŸ¤ {bcolors.CYAN}--- ä¿®æ”¹æ¨¡å¼ ({modified_current_index + 1}/{len(modified_playback_list)}) ---")
        print(f"   (Excel åŸå§‹è¡Œå·: {original_row})")
        print(f"   æ‰«ç›²è¯: '{user_input_text}'")
        print(f"   å®Œæ•´å¥: '{sentence}'")
        print(f"   å£°  éŸ³: {voice_info} (å½“å‰ä½¿ç”¨: {active_voice_id})")
        UI.separator()
        
        speak_sentence(user_input_text, active_voice_id)
        UI.info("... 1ç§’åæœ—è¯»å®Œæ•´å¥å­ ...")
        time.sleep(1)
        speak_sentence(sentence, active_voice_id)

        while True:
            UI.separator()
            prompt_text = "æŒ‡ä»¤: (e)æ‰«ç›², (s)å¥å­, (w)å•è¯, (.)ä¸‹ä¸€å¥/åˆ é™¤, (l)ä¸Šä¸€å¥, (z)æ¢äºº, (Enter)é‡å¬, (q)é€€å‡º: "
            user_command = UI.prompt(prompt_text).strip().lower()

            if user_command in ['.', 'ã€‚', 'n', 'l', 'q', 'm', '2'] or (user_command and not user_command in ['e','s','w','z','v',''] and not find_country_by_code(user_command, country_code_map)):
                break

            if user_command == 'e':
                handle_blind_spot_logging(sentence, voice_info)
            elif user_command == 's':
                user_spelling = handle_spelling_session(sentence, active_voice_id)
                if user_spelling is not None:
                    is_correct, highlighted_string = check_and_highlight_spelling(sentence, user_spelling)
                    print(f"âœï¸  {bcolors.CYAN}--- æ‹¼å†™æ£€æŸ¥ç»“æœ ---{bcolors.ENDC}"); print(f"   ç»“æœ: {highlighted_string}")
                    if is_correct: UI.success("å¥å­æ‹¼å†™å®Œå…¨æ­£ç¡®ï¼")
                    else: UI.error("å¥å­æ‹¼å†™æœ‰è¯¯ã€‚"); save_spelling_error_sentence(sentence)
            elif user_command == 'w':
                user_words_input = handle_spelling_session(sentence, active_voice_id)
                if user_words_input is not None:
                    translator = str.maketrans('', '', string.punctuation)
                    clean_original_words = {word.translate(translator).lower() for word in sentence.split()}
                    user_words = user_words_input.split()
                    all_found, not_found_words = True, []
                    for word in user_words:
                        if word.strip() and word.translate(translator).lower() not in clean_original_words:
                            all_found, not_found_words = False, not_found_words + [word]
                    if all_found: UI.success(f"å•è¯/è¯ç»„ '{user_words_input}' å‡å­˜åœ¨äºå¥å­ä¸­ï¼Œæ‹¼å†™æ­£ç¡®ï¼")
                    else: UI.error(f"å•è¯ '{', '.join(not_found_words)}' ä¸åœ¨å¥å­ä¸­æˆ–æ‹¼å†™é”™è¯¯ã€‚"); save_spelling_error_sentence(sentence)
            elif user_command == 'z':
                if TTS_ENGINE == 'edge':
                    UI.info("æ­£åœ¨å°è¯•åˆ‡æ¢å£°éŸ³...")
                    country = None
                    match = re.search(r'Edge-TTS:\s*([^,]+),', str(voice_info))
                    if match:
                        country_name_part = match.group(1).strip()
                        if country_name_part in voices_by_country: country = country_name_part
                    if country:
                        available_voices = [v for v in voices_by_country[country] if v != active_voice_id]
                        if available_voices:
                            new_voice = random.choice(available_voices)
                            session_voice_override = new_voice
                            UI.success(f"å·²ä¸´æ—¶åˆ‡æ¢åˆ°æ–°å£°éŸ³: {session_voice_override}")
                            active_voice_id = new_voice
                            speak_sentence(user_input_text, active_voice_id)
                            UI.info("... 1ç§’åæœ—è¯»å®Œæ•´å¥å­ ...")
                            time.sleep(1)
                            speak_sentence(sentence, active_voice_id)
                        else: UI.error(f"'{country}' æ²¡æœ‰å…¶ä»–å¯ç”¨å£°éŸ³æ¥åˆ‡æ¢ã€‚")
                    else: UI.error("æ— æ³•ä»å£°éŸ³ä¿¡æ¯ä¸­ç¡®å®šå›½å®¶ï¼Œæ— æ³•åˆ‡æ¢ã€‚")
                else:
                    UI.info("gTTSæ¨¡å¼ä¸‹æ— æ³•åˆ‡æ¢å•ä¸ªå£°éŸ³ï¼Œè¯·ä½¿ç”¨å›½å®¶ä»£ç  (å¦‚ 'uk', 'us') åˆ‡æ¢å£éŸ³ã€‚")
            elif user_command == '':
                speak_sentence(user_input_text, active_voice_id)
                UI.info("... 1ç§’åæœ—è¯»å®Œæ•´å¥å­ ...")
                time.sleep(1)
                speak_sentence(sentence, active_voice_id)
            else: 
                matched_country = find_country_by_code(user_command, country_code_map)
                if matched_country:
                    default_country = matched_country
                    UI.info(f"å›½å®¶/å£éŸ³å·²åˆ‡æ¢åˆ°: {default_country}ã€‚")
                    session_voice_override = None 
                    break 

        if user_command in ['.', 'ã€‚', 'n']:
            if delete_specific_blind_spot_from_excel(MODIFIED_BLIND_SPOT_LOG_PATH, sentence, user_input_text):
                modified_playback_list.pop(modified_current_index)
            else:
                modified_current_index += 1
            session_voice_override = None 
        elif user_command == 'l':
            modified_current_index = max(0, modified_current_index - 1)
            session_voice_override = None 
        elif user_command == 'q': return 'QUIT'
        elif user_command == 'm': return 'GOTO_MENU'
        elif user_command == '2': return 'SWITCH_TO_2'
        else:
            word_to_lookup_on_switch = user_command
            return 'SWITCH_TO_2_WITH_WORD'
        
    UI.success("æ‰€æœ‰ä»»åŠ¡å·²å®Œæˆï¼"); 
    return 'GOTO_MENU'

if __name__ == "__main__":
    def choose_app_mode():
        global APP_MODE, speech_app_initialized, modified_app_initialized
        APP_MODE = None
        while APP_MODE not in ['original', 'modified']:
            UI.header("è¿è¡Œæ¨¡å¼é€‰æ‹©")
            print("è¯·é€‰æ‹©æœ¬æ¬¡è¿è¡Œæ¨¡å¼ï¼š")
            print(f"1. {bcolors.GREEN}åŸæ¨¡å¼{bcolors.ENDC} (ä» '{os.path.basename(SPEECH_EXCEL_PATH)}' è¯»å–å¹¶éšæœºæœ—è¯»)")
            print(f"2. {bcolors.YELLOW}ä¿®æ”¹åæ¨¡å¼{bcolors.ENDC} (ä»¥ '{os.path.basename(SPEECH_EXCEL_PATH)}' ä¸ºä¸»çº¿ï¼Œè¯»ååˆ é™¤æ‰«ç›²æ—¥å¿—å¯¹åº”è¡Œ)")
            UI.separator()
            choice = UI.prompt("è¯·è¾“å…¥é€‰æ‹© (1 æˆ– 2): ").strip()
            if choice == '1': APP_MODE = 'original'; UI.success("å·²é€‰æ‹© åŸæ¨¡å¼ã€‚")
            elif choice == '2': APP_MODE = 'modified'; UI.success("å·²é€‰æ‹© ä¿®æ”¹åæ¨¡å¼ã€‚")
            else: UI.error("æ— æ•ˆè¾“å…¥ï¼Œè¯·è¾“å…¥ 1 æˆ– 2ã€‚")
            UI.separator()
        speech_app_initialized = False
        modified_app_initialized = False

    def choose_tts_engine():
        global TTS_ENGINE
        while TTS_ENGINE not in ['edge', 'gtts']:
            UI.header("è¯­éŸ³å¼•æ“é€‰æ‹©")
            print("è¯·é€‰æ‹©æœ¬æ¬¡è¿è¡Œä½¿ç”¨çš„è¯­éŸ³å¼•æ“ï¼š"); print(f"1. {bcolors.GREEN}Edge-TTS{bcolors.ENDC}"); print(f"2. {bcolors.YELLOW}gTTS{bcolors.ENDC}"); UI.separator()
            choice = UI.prompt("è¯·è¾“å…¥é€‰æ‹© (1 æˆ– 2): ").strip()
            if choice == '1': TTS_ENGINE = 'edge'; UI.success("å·²é€‰æ‹© Edge-TTS å¼•æ“ã€‚")
            elif choice == '2': TTS_ENGINE = 'gtts'; UI.success("å·²é€‰æ‹© gTTS å¼•æ“ã€‚")
            else: UI.error("æ— æ•ˆè¾“å…¥ï¼Œè¯·è¾“å…¥ 1 æˆ– 2ã€‚")
            UI.separator()
    
    choose_app_mode()
    choose_tts_engine()

    DICTIONARY_CHOICE = None
    def choose_dictionary():
        global DICTIONARY_CHOICE
        while DICTIONARY_CHOICE not in ['1', '2']:
            UI.header("è¯å…¸é€‰æ‹©"); print("1. DictionaryAPI"); print("2. Merriam-Webster"); UI.separator()
            DICTIONARY_CHOICE = UI.prompt("è¯·è¾“å…¥é€‰æ‹© (1 æˆ– 2): ").strip()
    choose_dictionary()

    if TTS_ENGINE == 'edge': voices_by_country = create_voice_map_dynamically(country_code_map, voices_by_country)
    process_word_cache_on_startup()
    
    if APP_MODE == 'modified':
        preprocess_choice = UI.prompt("æ˜¯å¦éœ€è¦åœ¨å¼€å§‹å‰è¿è¡Œæ•°æ®é¢„å¤„ç†ï¼ˆåŒ¹é…å’Œæ›´æ–°å¥å­ï¼‰ï¼Ÿ (y/N): ").lower()
        if preprocess_choice == 'y':
            if not run_sentence_replacement_logic():
                UI.error("æ•°æ®é¢„å¤„ç†å¤±è´¥ï¼Œç¨‹åºæ— æ³•ç»§ç»­ã€‚"); sys.exit(1)

    current_app = 'menu'
    user_quit = False
    try:
        while not user_quit:
            if current_app == 'menu':
                UI.header("ä¸»èœå•");
                current_mode_display = "åŸæ¨¡å¼" if APP_MODE == 'original' else "ä¿®æ”¹åæ¨¡å¼"
                print(f"1. äº¤äº’å¼è¯­éŸ³æœ—è¯»ç¨‹åº (å½“å‰: {bcolors.GREEN}{current_mode_display}{bcolors.ENDC})")
                print("2. åœ¨çº¿è¯å…¸æŸ¥è¯¢")
                print("3. åˆ‡æ¢å­¦ä¹ æ¨¡å¼")
                print("q. é€€å‡ºç¨‹åº");
                UI.separator()
                choice = UI.prompt("è¯·è¾“å…¥ä½ çš„é€‰æ‹© (1, 2, 3 æˆ– q): ").strip().lower()
                if choice == '1': 
                    current_app = '1_modified' if APP_MODE == 'modified' else '1'
                elif choice == '2': current_app = '2'
                elif choice == '3':
                    choose_app_mode()
                elif choice == 'q': user_quit = True
                else: UI.error("æ— æ•ˆçš„é€‰æ‹©ã€‚"); UI.separator()
            
            elif current_app == '1_modified':
                if not initialize_modified_app():
                    UI.info("åˆå§‹åŒ–å¤±è´¥æˆ–ä»»åŠ¡åˆ—è¡¨ä¸ºç©ºï¼Œè¿”å›ä¸»èœå•ã€‚")
                    current_app = 'menu'
                    continue
                
                action = run_modified_speech_app()
                
                if action == 'GOTO_MENU':
                    current_app = 'menu'
                elif action == 'QUIT':
                    user_quit = True
                elif action == 'SWITCH_TO_2':
                    current_app = '2'
                elif action == 'SWITCH_TO_2_WITH_WORD':
                    action_dict = run_dictionary_loop(word_to_lookup_on_switch if word_to_lookup_on_switch else None)
                    word_to_lookup_on_switch = None
                    if action_dict == 'QUIT': user_quit = True
                    current_app = '1_modified'
                
            elif current_app == '1':
                if not initialize_speech_app(): current_app = 'menu'; continue
                
                if current_index >= len(sentences):
                    if prompt_for_error_rerun('original'):
                        continue
                    else:
                        UI.success("æ‰€æœ‰å¥å­å·²æœ—è¯»å®Œæ¯•ï¼è¿”å›ä¸»èœå•ã€‚"); UI.separator(); speech_app_initialized = False; sentences = []; current_app = 'menu'
                        for f in [STATE_FILE, LEFTOVER_FILE]:
                            if os.path.exists(f): os.remove(f)
                        continue

                action = handle_speech_interaction()
                if isinstance(action, tuple) and action[0] == 'SWITCH_TO_2_WITH_WORD': word_to_lookup_on_switch = action[1]; current_app = '2'
                elif action == 'SWITCH_TO_2': current_app = '2'
                elif action == 'GOTO_MENU': current_app = 'menu'
                elif action == 'QUIT':
                    if prompt_for_error_rerun('original'):
                        current_app = 'menu'
                    else:
                        user_quit = True
            
            elif current_app == '2':
                action = run_dictionary_loop(word_to_lookup_on_switch if word_to_lookup_on_switch else None); word_to_lookup_on_switch = None
                if action == 'SWITCH_TO_1': 
                    current_app = '1_modified' if APP_MODE == 'modified' else '1'
                elif action == 'GOTO_MENU': current_app = 'menu'
                elif action == 'QUIT': user_quit = True
    finally:
        UI.info("æ­£åœ¨æ‰§è¡Œé€€å‡ºæ¸…ç†ç¨‹åº..."); 
        cleanup_on_exit()